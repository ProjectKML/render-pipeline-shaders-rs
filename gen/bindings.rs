/* automatically generated by rust-bindgen 0.63.0 */

use ash::vk::*;

#[doc = " Successful completion."]
pub const RpsResult_RPS_OK: RpsResult = 0;
#[doc = " Failure due to an unspecified error."]
pub const RpsResult_RPS_ERROR_UNSPECIFIED: RpsResult = -1;
#[doc = " Failure due to an unrecognized command."]
pub const RpsResult_RPS_ERROR_UNRECOGNIZED_COMMAND: RpsResult = -2;
#[doc = " Failure due to invalid arguments."]
pub const RpsResult_RPS_ERROR_INVALID_ARGUMENTS: RpsResult = -3;
#[doc = " Failure due to invalid data."]
pub const RpsResult_RPS_ERROR_INVALID_DATA: RpsResult = -4;
#[doc = " Failure due to an invalid operation."]
pub const RpsResult_RPS_ERROR_INVALID_OPERATION: RpsResult = -5;
#[doc = " Failure due to running out of memory."]
pub const RpsResult_RPS_ERROR_OUT_OF_MEMORY: RpsResult = -6;
#[doc = " Failure due to not being able to find the specified file."]
pub const RpsResult_RPS_ERROR_FILE_NOT_FOUND: RpsResult = -7;
#[doc = " Failure due to an invalid file format."]
pub const RpsResult_RPS_ERROR_INVALID_FILE_FORMAT: RpsResult = -8;
#[doc = " Failure due to the file format version being too old."]
pub const RpsResult_RPS_ERROR_UNSUPPORTED_VERSION_TOO_OLD: RpsResult = -9;
#[doc = " Failure due to the file format version being too new."]
pub const RpsResult_RPS_ERROR_UNSUPPORTED_VERSION_TOO_NEW: RpsResult = -10;
#[doc = " Failure due to an unknown node."]
pub const RpsResult_RPS_ERROR_UNKNOWN_NODE: RpsResult = -11;
#[doc = " Failure due to an index being out of its valid bounds."]
pub const RpsResult_RPS_ERROR_INDEX_OUT_OF_BOUNDS: RpsResult = -12;
#[doc = " Failure due to a command being already finalized."]
pub const RpsResult_RPS_ERROR_COMMAND_ALREADY_FINAL: RpsResult = -13;
#[doc = " Failure due to a data layout mismatch between runtime and shader."]
pub const RpsResult_RPS_ERROR_INTEROP_DATA_LAYOUT_MISMATCH: RpsResult = -14;
#[doc = " Failure due to a key not being found."]
pub const RpsResult_RPS_ERROR_KEY_NOT_FOUND: RpsResult = -15;
#[doc = " Failure due to a key value being duplicated where it is required to be unique."]
pub const RpsResult_RPS_ERROR_KEY_DUPLICATED: RpsResult = -16;
#[doc = " Failure due to a feature not being implemented yet."]
pub const RpsResult_RPS_ERROR_NOT_IMPLEMENTED: RpsResult = -17;
#[doc = " Failure due to an integer overflow."]
pub const RpsResult_RPS_ERROR_INTEGER_OVERFLOW: RpsResult = -18;
#[doc = " Failure due to exclusive ranges overlapping."]
pub const RpsResult_RPS_ERROR_RANGE_OVERLAPPING: RpsResult = -19;
#[doc = " Failure due to rpsRenderPipelineValidate finding an invalid pipeline configuration. More details are provided\n via output of the device print function."]
pub const RpsResult_RPS_ERROR_VALIDATION_FAILED: RpsResult = -20;
#[doc = " Failure due to a compiled RPSL shader program being ill formed. Normally indicates a compiler error."]
pub const RpsResult_RPS_ERROR_INVALID_PROGRAM: RpsResult = -21;
#[doc = " Failure due to an RPSL module being incompatible with the current runtime."]
pub const RpsResult_RPS_ERROR_UNSUPPORTED_MODULE_VERSION: RpsResult = -22;
#[doc = " Failure due to a failed type safety check."]
pub const RpsResult_RPS_ERROR_TYPE_MISMATCH: RpsResult = -23;
#[doc = " Failure due to a feature not being supported."]
pub const RpsResult_RPS_ERROR_NOT_SUPPORTED: RpsResult = -24;
#[doc = " Failure due to failed a runtime API without direct mapping of the API error code."]
pub const RpsResult_RPS_ERROR_RUNTIME_API_ERROR: RpsResult = -25;
#[doc = " Failure due to an RPS library internal error."]
pub const RpsResult_RPS_ERROR_INTERNAL_ERROR: RpsResult = -26;
#[doc = " Number of unique RPS result codes."]
pub const RpsResult_RPS_RESULT_CODE_COUNT: RpsResult = 27;
#[doc = " @brief Result and error codes used by operations of the RPS library.\n\n @ingroup Basic"]
pub type RpsResult = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Gets the name string of a result code.\n\n @param result       Result code.\n\n @returns            Null terminated string with the result name."]
    pub fn rpsResultGetName(result: RpsResult) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Boolean value type."]
pub type RpsBool = i32;
#[doc = " @brief Type for holding up to 16 bitflags."]
pub type RpsFlags16 = u16;
#[doc = " @brief Type for holding up to 32 bitflags."]
pub type RpsFlags32 = u32;
#[doc = " @brief Type for holding up to 64 bitflags."]
pub type RpsFlags64 = u64;
#[doc = " @brief Type for general 32-bit index values."]
pub type RpsIndex32 = u32;
#[doc = " @brief Signature of functions for allocating memory.\n\n @param pContext                 Context for memory allocation.\n @param size                     Size of the desired allocation in bytes.\n @param alignment                Minimum alignment requirement of the desired allocation in bytes.\n\n @returns                        Pointer to the allocated memory."]
pub type PFN_rpsAlloc = ::std::option::Option<unsafe extern "C" fn(pContext: *mut ::std::os::raw::c_void, size: usize, alignment: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " @brief Signature of functions for reallocating memory.\n\n @param pUserContext             Context for memory allocation.\n @param oldBuffer                Address of the memory allocation to be reallocated.\n                                 Must not be NULL for oldSize != 0.\n @param oldSize                  Size of the old memory allocation in bytes.\n @param newSize                  Desired size of the allocation in bytes.\n @param alignment                Minimum alignment requirement of the desired allocation in bytes.\n\n @returns                        Pointer to the (re-)allocated memory."]
pub type PFN_rpsRealloc = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        oldBuffer: *mut ::std::os::raw::c_void,
        oldSize: usize,
        newSize: usize,
        alignment: usize
    ) -> *mut ::std::os::raw::c_void
>;
#[doc = " @brief Signature of functions for freeing allocated memory.\n\n @param pUserContext             Context for memory allocation.\n @param buffer                   Address of the memory allocation to be freed."]
pub type PFN_rpsFree = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, buffer: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Memory allocator interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAllocator {
    #[doc = "< Pointer to a function for allocating memory."]
    pub pfnAlloc: PFN_rpsAlloc,
    #[doc = "< Pointer to a function for releasing memory."]
    pub pfnFree: PFN_rpsFree,
    #[doc = "< Pointer to a function for reallocating memory."]
    pub pfnRealloc: PFN_rpsRealloc,
    #[doc = "< Context to be passed to the allocator functions."]
    pub pContext: *mut ::std::os::raw::c_void
}
#[doc = " @brief Requirements for a single memory allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAllocInfo {
    #[doc = "< Size of the allocation in bytes."]
    pub size: usize,
    #[doc = "< Minimum alignment requirement of the allocation in bytes."]
    pub alignment: usize
}
#[doc = " @brief Signature of functions for printing with variadic arguments.\n\n @param pContext                 Context for printing. See <c><i>RpsPrinter</i></c>.\n @param format                   Format string for the print operation matching the C99 specification for printf.\n @param ...                      List of arguments matching the requirements of the contents of <c><i>format</i></c>."]
pub type PFN_rpsPrintf = ::std::option::Option<unsafe extern "C" fn(pContext: *mut ::std::os::raw::c_void, format: *const ::std::os::raw::c_char, ...)>;
#[doc = " @brief Signature of functions for printing with a variable argument list.\n\n @param pContext                 Context for printing. See <c><i>RpsPrinter</i></c>.\n @param format                   Format string for the print operation matching the C99 specification for printf.\n @param vl                       Variable argument list matching the requirements of the contents of\n                                 <c><i>format</i></c>."]
pub type PFN_rpsVPrintf = ::std::option::Option<unsafe extern "C" fn(pContext: *mut ::std::os::raw::c_void, format: *const ::std::os::raw::c_char)>;
#[doc = " @brief Printer interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsPrinter {
    #[doc = "< Pointer to a function for printing with variadic arguments."]
    pub pfnPrintf: PFN_rpsPrintf,
    #[doc = "< Pointer to a function for printing with a variable argument list."]
    pub pfnVPrintf: PFN_rpsVPrintf,
    #[doc = "< Context to be passed to the print functions."]
    pub pContext: *mut ::std::os::raw::c_void
}
#[doc = " @brief Signature of functions for generating random integers uniformly distributed on the closed interval\n [minValue, maxValue].\n\n @param pContext                 Context for generating random numbers.\n @param minValue                 Minimum output value.\n @param maxValue                 Maximum output value.\n\n @returns                        Generated uniform random value."]
pub type PFN_rpsRandomUniformInt = ::std::option::Option<unsafe extern "C" fn(pContext: *mut ::std::os::raw::c_void, minValue: i32, maxValue: i32) -> i32>;
#[doc = " @brief Random number generator interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRandomNumberGenerator {
    #[doc = "< Pointer to a function for generating random uniform integers."]
    pub pfnRandomUniformInt: PFN_rpsRandomUniformInt,
    #[doc = "< Context to be passed to the generator function."]
    pub pContext: *mut ::std::os::raw::c_void
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDevice_T {
    _unused: [u8; 0]
}
pub type RpsDevice = *mut RpsDevice_T;
#[doc = " @brief Signature of functions for destroying device objects.\n\n @param hDevice      Handle to the <c><i>RpsDevice</i></c> object to destroy."]
pub type PFN_rpsDeviceOnDestroy = ::std::option::Option<unsafe extern "C" fn(hDevice: RpsDevice)>;
#[doc = " @brief Creation parameters for an <c><i>RpsDevice</i></c>."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDeviceCreateInfo {
    #[doc = "< Default allocator to be usable for all memory allocations which do"]
    pub allocator: RpsAllocator,
    #[doc = "< Default printer to be usable for all printing operations which do"]
    pub printer: RpsPrinter,
    #[doc = "< Allocation info for user controlled data which is part of the"]
    pub privateDataAllocInfo: RpsAllocInfo,
    #[doc = "< Pointer to a function for eventual destruction of the device."]
    pub pfnDeviceOnDestroy: PFN_rpsDeviceOnDestroy
}
extern "C" {
    #[doc = " @brief Creates a device object.\n\n @param pCreateInfo                  Pointer to creation parameters. Passing NULL initializes the device with default\n                                     parameters.\n @param pHDevice                     Pointer in which the device object is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsDeviceCreate(pCreateInfo: *const RpsDeviceCreateInfo, pHDevice: *mut RpsDevice) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Destroys an RPS device object.\n\n @param hDevice                      Handle to the <c><i>RpsDevice</i></c>."]
    pub fn rpsDeviceDestroy(hDevice: RpsDevice);
}
extern "C" {
    #[doc = " @brief Accesses user data of an RPS device.\n\n This user is normally not the API user but RPS itself. The device private data is created at device allocation,\n based on privateDataAllocInfo and the device itself will never touch the data until it is destroyed.\n\n @param hDevice                      Handle to the <c><i>RpsDevice</i></c>.\n\n @returns                            Pointer to the user controlled data if a handle != RPS_NULL_HANDLE is passed,\n                                     NULL otherwise."]
    pub fn rpsDeviceGetPrivateData(hDevice: RpsDevice) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Sets the global debug printer which is used for diagnostic purposes when no device context is available.\n\n @param pPrinter                     Pointer to the printer to set."]
    pub fn rpsSetGlobalDebugPrinter(pPrinter: *const RpsPrinter);
}
extern "C" {
    #[doc = " @brief Gets the global debug printer.\n\n @returns                            Pointer to the current debug printer."]
    pub fn rpsGetGlobalDebugPrinter() -> *const RpsPrinter;
}
#[doc = " @brief Parameters of a type used in the RPS library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsTypeInfo {
    #[doc = "< Size of a single instance in bytes."]
    pub size: u16,
    #[doc = "< Unique identifier of the type."]
    pub id: u16
}
#[doc = "< General type with specified size."]
pub const RpsBuiltInTypeIds_RPS_TYPE_OPAQUE: RpsBuiltInTypeIds = 0;
#[doc = "< 32-bit boolean type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_BOOL: RpsBuiltInTypeIds = 1;
#[doc = "< 8-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT8: RpsBuiltInTypeIds = 2;
#[doc = "< 8-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT8: RpsBuiltInTypeIds = 3;
#[doc = "< 16-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT16: RpsBuiltInTypeIds = 4;
#[doc = "< 16-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT16: RpsBuiltInTypeIds = 5;
#[doc = "< 32-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT32: RpsBuiltInTypeIds = 6;
#[doc = "< 32-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT32: RpsBuiltInTypeIds = 7;
#[doc = "< 64-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT64: RpsBuiltInTypeIds = 8;
#[doc = "< 64-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT64: RpsBuiltInTypeIds = 9;
#[doc = "< 32-bit floating point type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_FLOAT32: RpsBuiltInTypeIds = 10;
#[doc = "< 64-bit floating point type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_FLOAT64: RpsBuiltInTypeIds = 11;
#[doc = "< Number of built-in types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_MAX_VALUE: RpsBuiltInTypeIds = 12;
#[doc = "< Starting value of the type id range reserved for runtime defined types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_RUNTIME_DEFINED_BEGIN: RpsBuiltInTypeIds = 64;
#[doc = "< Starting value of the type id range reserved for user defined types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_USER_DEFINED_BEGIN: RpsBuiltInTypeIds = 256;
#[doc = " @brief Integer type ids for all built-in types, e.g. integers and floating point types."]
pub type RpsBuiltInTypeIds = ::std::os::raw::c_uint;
#[doc = " @brief Integer type ids for any kind of type."]
pub type RpsTypeId = u32;
#[doc = " @brief Type for render graph node declaration identifiers."]
pub type RpsNodeDeclId = u32;
#[doc = " @brief Type for function parameter identifiers."]
pub type RpsParamId = u32;
#[doc = " @brief Type for render graph node identifiers."]
pub type RpsNodeId = u32;
#[doc = " @brief Transparent handle type for a general render graph variable."]
pub type RpsVariable = *mut ::std::os::raw::c_void;
#[doc = " @brief Transparent handle type for a general, immutable render graph variable."]
pub type RpsConstant = *const ::std::os::raw::c_void;
#[doc = "< No subgraph properties."]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_NONE: RpsSubgraphFlagBits = 0;
#[doc = "< The subgraph is atomic, so external nodes may not be reorderd"]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_ATOMIC: RpsSubgraphFlagBits = 1;
#[doc = "< The subgraph is sequential, the relative order of its nodes should be"]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_SEQUENTIAL: RpsSubgraphFlagBits = 2;
#[doc = " @brief Bitflags for subgraph properties."]
pub type RpsSubgraphFlagBits = ::std::os::raw::c_uint;
#[doc = "  @brief Bitmask type for <c><i>RpsSubgraphFlagBits</i></c>."]
pub type RpsSubgraphFlags = RpsFlags32;
#[doc = " @brief Type for files represented by an RPSL internal integer identifier."]
pub type RpsSourceFileId = RpsIndex32;
#[doc = " @brief Parameters of a source code location."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSourceLocation {
    #[doc = "< Identifier for a file."]
    pub file: RpsSourceFileId,
    #[doc = "< Line number within the file."]
    pub line: u32
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDebugInfo {
    _unused: [u8; 0]
}
#[doc = " Bitmask type for an internal entry flags type."]
pub type RpslEntryCallFlags = RpsFlags32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRpslEntry_T {
    _unused: [u8; 0]
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___rpsl_runtime_procs {
    _unused: [u8; 0]
}

#[doc = " @brief Type for RPSL entry point declarations.\n\n An RpslEntry is defined by an export function entry in RPSL and usually statically linked or dynamically loaded into\n the application. It contains the signature info and the function entry point. Users can use the subsequent macros to\n define such an entry point for usage in their application when binding nodes."]
pub type RpsRpslEntry = *const RpsRpslEntry_T;
#[doc = " @brief Signature of functions for initializing RPSL processes from a DLL.\n\n @param pProcs\n @param sizeofProcs\n\n returns"]
pub type PFN_rpslDynLibInit = ::std::option::Option<unsafe extern "C" fn(pProcs: *const ___rpsl_runtime_procs, sizeofProcs: u32) -> i32>;
extern "C" {
    #[doc = " @brief Initializes an RPSL DLL module.\n\n The user can create an RPSL DLL module by linking rpsl code with rps_rpsl_host_dll.c. After this DLL is loaded, the\n user must get the address of the `___rps_dyn_lib_init` entry point and call rpsRpslDynamicLibraryInit with this\n entry point address as the parameter. This initializes the RPSL runtime callbacks for the DLL.\n\n @param pfn_dynLibInit               Address of \"___rps_dyn_lib_init\" entry point of the RPSL DLL module.\n\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRpslDynamicLibraryInit(pfn_dynLibInit: PFN_rpslDynLibInit) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Generates an RPSL entry name.\n\n Generates the name from the given module and entry names, so that it matches the symbol name generated by the RPSL\n compiler for this entry. This name can be used to retrieve the RpslEntry address from a dynamically loaded library\n using e.g. GetProcAddress or dlsym.\n\n @param pBuf                         Pointer in which the name is returned. Must not be NULL.\n @param bufSize                      Size of the buffer in bytes.\n @param moduleName                   Null terminated string with the name of the module.\n @param entryName                    Null terminated string with the name of the entry point.\n\n @returns                            Pointer to the buffer if its size is large enough, otherwise NULL."]
    pub fn rpsMakeRpslEntryName(
        pBuf: *mut ::std::os::raw::c_char,
        bufSize: usize,
        moduleName: *const ::std::os::raw::c_char,
        entryName: *const ::std::os::raw::c_char
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsJITModule_T {
    _unused: [u8; 0]
}
pub type RpsJITModule = *mut RpsJITModule_T;
#[doc = "< Unknown format."]
pub const RpsFormat_RPS_FORMAT_UNKNOWN: RpsFormat = 0;
#[doc = "< 4-channel RGBA format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_TYPELESS: RpsFormat = 1;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit IEEE 754 floating"]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_FLOAT: RpsFormat = 2;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_UINT: RpsFormat = 3;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_SINT: RpsFormat = 4;
#[doc = "< 3-channel RGB format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_TYPELESS: RpsFormat = 5;
#[doc = "< 3-channel RGB format with each channel being a 32-bit IEEE 754 floating"]
pub const RpsFormat_RPS_FORMAT_R32G32B32_FLOAT: RpsFormat = 6;
#[doc = "< 3-channel RGB format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_UINT: RpsFormat = 7;
#[doc = "< 3-channel RGB format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_SINT: RpsFormat = 8;
#[doc = "< 4-channel RGBA format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_TYPELESS: RpsFormat = 9;
#[doc = "< 4-channel RGBA format with each channel being a 16-bit floating point"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_FLOAT: RpsFormat = 10;
#[doc = "< 4-channel RGBA format with each channel being a normalized, 16-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_UNORM: RpsFormat = 11;
#[doc = "< 4-channel RGBA format with each channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_UINT: RpsFormat = 12;
#[doc = "< 4-channel RGBA format with each channel being a normalized, 16-bit signed"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_SNORM: RpsFormat = 13;
#[doc = " 4-channel RGBA format with each channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_SINT: RpsFormat = 14;
#[doc = " 2-channel RG format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32_TYPELESS: RpsFormat = 15;
#[doc = " 2-channel RG format with each channel being a 32-bit IEEE 754 floating point value."]
pub const RpsFormat_RPS_FORMAT_R32G32_FLOAT: RpsFormat = 16;
#[doc = " 2-channel RG format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32_UINT: RpsFormat = 17;
#[doc = " 2-channel RG format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32_SINT: RpsFormat = 18;
#[doc = " 2-channel RG format with the first channel being a typeless 32-bit value, the second channel a typeless 8-bit\n value and 24 unused bits at the end."]
pub const RpsFormat_RPS_FORMAT_R32G8X24_TYPELESS: RpsFormat = 19;
#[doc = " 2-channel RG format with the first channel being a 32-bit depth value, the second one a 8-bit unsigned integer\n value and 24 unused bits at the end."]
pub const RpsFormat_RPS_FORMAT_D32_FLOAT_S8X24_UINT: RpsFormat = 20;
#[doc = " Single channel R format with the channel being a typeless 32-bit IEEE 754 floating point value and additional\n sets of 8 and 24 unused bits afterwards."]
pub const RpsFormat_RPS_FORMAT_R32_FLOAT_X8X24_TYPELESS: RpsFormat = 21;
#[doc = " Single channel R format with 32 unused bits, the channel being an 8-bit unsigned integer value and 24 unused\n bits at the end."]
pub const RpsFormat_RPS_FORMAT_X32_TYPELESS_G8X24_UINT: RpsFormat = 22;
#[doc = " 4-channel RGBA format with the RGB channels being typeless 10-bit values and the A channel being a typeless\n 2-bit value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_TYPELESS: RpsFormat = 23;
#[doc = " 4-channel RGBA format with the RGB channels being 10-bit normalized, unsigned integer values and the A channel\n being a 2-bit normalized, unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_UNORM: RpsFormat = 24;
#[doc = " 4-channel RGBA format with the RGB channels being 10-bit unsigned integer values and the A channel being a 2-bit\n unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_UINT: RpsFormat = 25;
#[doc = " 3-channel RGB format with the RG channels being 11-bit floating point values and the B channel being a 10-bit\n floating point value."]
pub const RpsFormat_RPS_FORMAT_R11G11B10_FLOAT: RpsFormat = 26;
#[doc = "< 4-channel RGBA format with all channels being typeless 8-bit values."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_TYPELESS: RpsFormat = 27;
#[doc = "< 4-channel RGBA format with all channels being normalized 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UNORM: RpsFormat = 28;
#[doc = "< 4-channel RGBA format with all channels being normalized 8-bit unsigned integer"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UNORM_SRGB: RpsFormat = 29;
#[doc = "< 4-channel RGBA format with all channels being 8-bit unsigned integers."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UINT: RpsFormat = 30;
#[doc = "< 4-channel RGBA format with all channels being normalized, 8-bit signed"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_SNORM: RpsFormat = 31;
#[doc = "< 4-channel RGBA format with all channels being 8-bit signed integers."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_SINT: RpsFormat = 32;
#[doc = "< 2-channel RG format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16G16_TYPELESS: RpsFormat = 33;
#[doc = "< 2-channel RG format with each channel being a 16-bit IEEE 754 floating point value."]
pub const RpsFormat_RPS_FORMAT_R16G16_FLOAT: RpsFormat = 34;
#[doc = "< 2-channel RG format with each channel being a normalized, 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_UNORM: RpsFormat = 35;
#[doc = "< 2-channel RG format with each channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_UINT: RpsFormat = 36;
#[doc = "< 2-channel RG format with each channel being a normalized, 16-bit signed integer"]
pub const RpsFormat_RPS_FORMAT_R16G16_SNORM: RpsFormat = 37;
#[doc = "< 2-channel RG format with each channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_SINT: RpsFormat = 38;
#[doc = "< Single channel R format with the channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32_TYPELESS: RpsFormat = 39;
#[doc = "< Single channel R format with the channel being a 32-bit IEEE 754 floating point depth"]
pub const RpsFormat_RPS_FORMAT_D32_FLOAT: RpsFormat = 40;
#[doc = "< Single channel R format with the channel being a 32-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_R32_FLOAT: RpsFormat = 41;
#[doc = "< Single channel R format with the channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32_UINT: RpsFormat = 42;
#[doc = "< Single channel R format with the channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32_SINT: RpsFormat = 43;
#[doc = " 2-channel RG format with the first channel being a typeless 24-bit value and the second one a typeless 8-bit\n value."]
pub const RpsFormat_RPS_FORMAT_R24G8_TYPELESS: RpsFormat = 44;
#[doc = " 2-channel RG format with the first channel being a normalized, 24-bit unsigned integer depth value and the\n second one an 8-bit unsigned integer stencil value."]
pub const RpsFormat_RPS_FORMAT_D24_UNORM_S8_UINT: RpsFormat = 45;
#[doc = " 2-channel RG format with the first channel being a normalized, 24-bit unsigned integer value and the second one\n a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R24_UNORM_X8_TYPELESS: RpsFormat = 46;
#[doc = " Single channel R format with 24 unused bits with the channel being an 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_X24_TYPELESS_G8_UINT: RpsFormat = 47;
#[doc = "< 2-channel RG format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R8G8_TYPELESS: RpsFormat = 48;
#[doc = "< 2-channel RG format with each channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_UNORM: RpsFormat = 49;
#[doc = "< 2-channel RG format with each channel being a 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_UINT: RpsFormat = 50;
#[doc = "< 2-channel RG format with each channel being a normalized, 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_SNORM: RpsFormat = 51;
#[doc = "< 2-channel RG format with each channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_SINT: RpsFormat = 52;
#[doc = "< Single channel R format with the channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16_TYPELESS: RpsFormat = 53;
#[doc = "< Single channel R format with the channel being a 16-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_R16_FLOAT: RpsFormat = 54;
#[doc = "< Single channel R format with the channel being a 16-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_D16_UNORM: RpsFormat = 55;
#[doc = "< Single channel R format with the channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16_UNORM: RpsFormat = 56;
#[doc = "< Single channel R format with the channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_UINT: RpsFormat = 57;
#[doc = "< Single channel R format with the channel being a normalized, 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_SNORM: RpsFormat = 58;
#[doc = "< Single channel R format with the channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_SINT: RpsFormat = 59;
#[doc = "< Single channel R format with the channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R8_TYPELESS: RpsFormat = 60;
#[doc = "< Single channel R format with the channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8_UNORM: RpsFormat = 61;
#[doc = "< Single channel R format with the channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_UINT: RpsFormat = 62;
#[doc = "< Single channel R format with the channel being a normalized, 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_SNORM: RpsFormat = 63;
#[doc = "< Single channel R format with the channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_SINT: RpsFormat = 64;
#[doc = "< Single channel A format with the channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_A8_UNORM: RpsFormat = 65;
#[doc = "< Single channel R format with the channel being a 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R1_UNORM: RpsFormat = 66;
#[doc = " 4-channel RGB format with the first three channels being a 9-bit mantissa. Together with the 5-bit exponent that\n is shared for all three channels they form three 9-bit mantissa + 5-bit exponent floating point value."]
pub const RpsFormat_RPS_FORMAT_R9G9B9E5_SHAREDEXP: RpsFormat = 67;
#[doc = " 4-channel RGB format with each channel being a normalized, 8-bit unsigned integer. Each block of 32 bits\n describes the RGB values for a pair of pixels that always share one R and B value but have separate G values."]
pub const RpsFormat_RPS_FORMAT_R8G8_B8G8_UNORM: RpsFormat = 68;
#[doc = " 4-channel RGB format with each channel being a normalized, 8-bit unsigned integer. Each block of 32 bits\n describes the RGB values for a pair of pixels that always share one R and B value but have separate G values."]
pub const RpsFormat_RPS_FORMAT_G8R8_G8B8_UNORM: RpsFormat = 69;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 0-bit or 1-bit value."]
pub const RpsFormat_RPS_FORMAT_BC1_TYPELESS: RpsFormat = 70;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 0-bit or 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC1_UNORM: RpsFormat = 71;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB valu eand the last one a normalized, 0-bit or 1-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC1_UNORM_SRGB: RpsFormat = 72;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 4-bit value."]
pub const RpsFormat_RPS_FORMAT_BC2_TYPELESS: RpsFormat = 73;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 4-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC2_UNORM: RpsFormat = 74;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB value and the last one a normalized, 4-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC2_UNORM_SRGB: RpsFormat = 75;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC3_TYPELESS: RpsFormat = 76;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC3_UNORM: RpsFormat = 77;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB value and the last one a normalized, 0-bit or 1-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC3_UNORM_SRGB: RpsFormat = 78;
#[doc = " Single channel block compressed format with the channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC4_TYPELESS: RpsFormat = 79;
#[doc = " Single channel block compressed format with the channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC4_UNORM: RpsFormat = 80;
#[doc = " Single channel block compressed format with the channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC4_SNORM: RpsFormat = 81;
#[doc = " 2-channel block compressed format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC5_TYPELESS: RpsFormat = 82;
#[doc = " 2-channel block compressed format with each channel being a normalized, 8-bit unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_BC5_UNORM: RpsFormat = 83;
#[doc = " 2-channel block compressed format with each channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC5_SNORM: RpsFormat = 84;
#[doc = " 3-channel BGR format with the first channel being a normalized, 5-bit unsigned integer, the second one a\n normalized, 6-bit unsigned integer and the third one a normalized, 5-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B5G6R5_UNORM: RpsFormat = 85;
#[doc = " 4-channel BGRA format with the first three channels being a normalized, 5-bit unsigned integer and the last one\n a normalized, 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B5G5R5A1_UNORM: RpsFormat = 86;
#[doc = " 4-channel BGRA format with each channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_UNORM: RpsFormat = 87;
#[doc = " 3-channel BGR format with each channel being a normalized, 8-bit unsigned integer value and 8 unused bits at the\n end."]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_UNORM: RpsFormat = 88;
#[doc = " 4-channel RGB 2.8-biased fixed-point format with the first three channels being a normalized, 10-bit\n unsigned integer and the last one a normalized 2-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R10G10B10_XR_BIAS_A2_UNORM: RpsFormat = 89;
#[doc = "< 4-channel BGRA format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_TYPELESS: RpsFormat = 90;
#[doc = "< 4-channel BGRA format with each channel being a normalized, 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_UNORM_SRGB: RpsFormat = 91;
#[doc = "< 3-channel BGR format with each channel being a typeless 8-bit value and 8"]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_TYPELESS: RpsFormat = 92;
#[doc = "< 3-channel BGR format with each channel being a normalized, 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_UNORM_SRGB: RpsFormat = 93;
#[doc = " 3-channel block compressed HDR format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_BC6H_TYPELESS: RpsFormat = 94;
#[doc = " 3-channel block compressed HDR format with each channel being a 16-bit unsigned \"half\" floating point value."]
pub const RpsFormat_RPS_FORMAT_BC6H_UF16: RpsFormat = 95;
#[doc = " 3-channel block compressed HDR format with each channel being a 16-bit signed \"half\" floating point value."]
pub const RpsFormat_RPS_FORMAT_BC6H_SF16: RpsFormat = 96;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being a typeless, 4-7-bit value and\n the last one an optional, typeless 0-8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC7_TYPELESS: RpsFormat = 97;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being an normalized, 4-7-bit\n unsigned integer and the last one an optional, normalized, 0-8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC7_UNORM: RpsFormat = 98;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being an normalized, 4-7-bit\n unsigned integer and the last one an optional, normalized, 0-8-bit unsigned integer ."]
pub const RpsFormat_RPS_FORMAT_BC7_UNORM_SRGB: RpsFormat = 99;
#[doc = "< 4-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_AYUV: RpsFormat = 100;
#[doc = "< 4-channel video resource format with each of the first three channels being a"]
pub const RpsFormat_RPS_FORMAT_Y410: RpsFormat = 101;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y416: RpsFormat = 102;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_NV12: RpsFormat = 103;
#[doc = "< 2-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_P010: RpsFormat = 104;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_P016: RpsFormat = 105;
#[doc = "< Video resource format with opaque layout."]
pub const RpsFormat_RPS_FORMAT_420_OPAQUE: RpsFormat = 106;
#[doc = "< 4-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_YUY2: RpsFormat = 107;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y210: RpsFormat = 108;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y216: RpsFormat = 109;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_NV11: RpsFormat = 110;
#[doc = "< 4-bit palletized video resource format."]
pub const RpsFormat_RPS_FORMAT_AI44: RpsFormat = 111;
#[doc = "< 4-bit palletized video resource format."]
pub const RpsFormat_RPS_FORMAT_IA44: RpsFormat = 112;
#[doc = "< RGB video resource format with 8-bit palletization."]
pub const RpsFormat_RPS_FORMAT_P8: RpsFormat = 113;
#[doc = "< RGB video resource format with 8-bit palletization."]
pub const RpsFormat_RPS_FORMAT_A8P8: RpsFormat = 114;
#[doc = "< 4-channels BGRA format with each channel being a normalized 4-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B4G4R4A4_UNORM: RpsFormat = 115;
#[doc = "< Number of formats available in <c><i>RpsFormat</i></c>."]
pub const RpsFormat_RPS_FORMAT_COUNT: RpsFormat = 116;
#[doc = " @brief Supported RPS formats."]
pub type RpsFormat = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Returns whether a format is block compressed.\n\n All block compressed formats start with the prefix RPS_FORMAT_BC.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format is block compressed, RPS_FALSE otherwise."]
    pub fn rpsFormatIsBlockCompressed(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a depth or a stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a depth or a stencil component, RPS_FALSE otherwise."]
    pub fn rpsFormatHasDepthStencil(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a depth component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a depth component, RPS_FALSE otherwise."]
    pub fn rpsFormatHasDepth(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a stencil component, RPS_FALSE otherwise."]
    pub fn rpsFormatHasStencil(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has only a depth component and no stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a stencil component and no stencil component, RPS_FALSE otherwise."]
    pub fn rpsFormatIsDepthOnly(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns the single element byte size for a format.\n\n For most formats one element is one pixel. This is different for block compressed formats, e.g.\n RPS_FORMAT_BC1_UNORM. The byte size of one block will be returned for these instead.\n\n @param format       Format to check.\n\n @returns            0 if the format does not support element wise usage, size of bytes of a single element otherwise."]
    pub fn rpsGetFormatElementBytes(format: RpsFormat) -> u32;
}
extern "C" {
    #[doc = " @brief Gets the name string of a format.\n\n @param format       Format to get its name for.\n\n @returns            Null terminated string with the format name."]
    pub fn rpsFormatGetName(format: RpsFormat) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Type for resource identifiers."]
pub type RpsResourceId = u32;
#[doc = "< Resource type is unknown / invalid."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_UNKNOWN: RpsResourceType = 0;
#[doc = "< A buffer resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_BUFFER: RpsResourceType = 1;
#[doc = "< A 1D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_1D: RpsResourceType = 2;
#[doc = "< A 2D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_2D: RpsResourceType = 3;
#[doc = "< A 3D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_3D: RpsResourceType = 4;
#[doc = "< Count of defined resource type values."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_COUNT: RpsResourceType = 5;
#[doc = " @brief Resource types used by RPS resources."]
pub type RpsResourceType = ::std::os::raw::c_uint;
#[doc = "< No special properties."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_NONE: RpsResourceFlagBits = 0;
#[doc = "< Supports cubemap views."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_CUBEMAP_COMPATIBLE_BIT: RpsResourceFlagBits = 2;
#[doc = "< Uses rowmajor image layout."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_ROWMAJOR_IMAGE_BIT: RpsResourceFlagBits = 4;
#[doc = "< Preferred to be in GPU-local CPU-visible heap"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PREFER_GPU_LOCAL_CPU_VISIBLE_BIT: RpsResourceFlagBits = 8;
#[doc = "< Preferred to be in dedicated allocation or as"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PREFER_DEDICATED_ALLOCATION_BIT: RpsResourceFlagBits = 16;
#[doc = "< Resource data is persistent from frame to"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PERSISTENT_BIT: RpsResourceFlagBits = 32768;
#[doc = " @brief Bitflags for special properties of a resource."]
pub type RpsResourceFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsResourceFlagBits</i></c>."]
pub type RpsResourceFlags = RpsFlags32;
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_UNKNOWN: RpsImageAspectUsageFlagBits = 0;
#[doc = " Image aspect usage is unknown."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_COLOR: RpsImageAspectUsageFlagBits = 1;
#[doc = " The color aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_DEPTH: RpsImageAspectUsageFlagBits = 2;
#[doc = " The depth aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_STENCIL: RpsImageAspectUsageFlagBits = 4;
#[doc = " The stencil aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_METADATA: RpsImageAspectUsageFlagBits = 8;
#[doc = " The metadata aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_DEFAULT: RpsImageAspectUsageFlagBits = 1;
#[doc = " @brief Bitflags for used aspects of an image resource."]
pub type RpsImageAspectUsageFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsImageAspectUsageFlagBits</i></c>."]
pub type RpsImageAspectUsageFlags = RpsFlags32;
#[doc = " @brief RGBA color value to use for clearing a resource.\n\n Depending on the underlaying format of a resource, an appropriately\n typed member of this union should be used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsClearColorValue {
    #[doc = "< 4-tuple of IEEE 754 floating point values representing an RGBA clear color."]
    pub float32: [f32; 4usize],
    #[doc = "< 4-tuple of signed integers representing an RGBA clear color."]
    pub int32: [i32; 4usize],
    #[doc = "< 4-tuple of unsigned integers representing an RGBA clear color."]
    pub uint32: [u32; 4usize]
}
#[doc = "< No clear flags are specified. (Not a valid use case)."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_NONE: RpsClearFlags = 0;
#[doc = "< Clears the color aspect of a render target view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_COLOR: RpsClearFlags = 1;
#[doc = "< Clears the depth aspect of a depth stencil view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_DEPTH: RpsClearFlags = 2;
#[doc = "< Clears the stencil aspect of a depth stencil view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_STENCIL: RpsClearFlags = 4;
#[doc = "< Clears the UAV with floating point data."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_UAVFLOAT: RpsClearFlags = 8;
#[doc = "< Clears the UAV with integer data."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_UAVUINT: RpsClearFlags = 16;
#[doc = " @brief Bitflags for the way a resource should be cleared."]
pub type RpsClearFlags = ::std::os::raw::c_uint;
#[doc = " @brief Parameters for clearing a depth stencil resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsClearDepthStencilValue {
    #[doc = "< Clear value for the depth aspect."]
    pub depth: f32,
    #[doc = "< Clear value for the stencil aspect."]
    pub stencil: u32
}
#[doc = " @brief General value a resource can be cleared to.\n\n Depending on the context and target resource view format, an appropriately\n typed member of this union should be used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsClearValue {
    #[doc = "< Clear value for a color resource."]
    pub color: RpsClearColorValue,
    #[doc = "< Clear value for a depth stencil resource."]
    pub depthStencil: RpsClearDepthStencilValue
}
#[doc = " @brief Parameters for clearing a resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsClearInfo {
    #[doc = "< Format of the resource view to use for clearing."]
    pub format: RpsFormat,
    #[doc = "< Clear value."]
    pub value: RpsClearValue
}
#[doc = " @brief Parameters for a resource description."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDesc {
    #[doc = "< Resource type."]
    pub type_: RpsResourceType,
    #[doc = "< Number of temporal layers the resource consists of."]
    pub temporalLayers: u32,
    #[doc = "< Resource flags for special properties."]
    pub flags: RpsResourceFlags,
    pub __bindgen_anon_1: RpsResourceDesc__bindgen_ty_1
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsResourceDesc__bindgen_ty_1 {
    pub image: RpsResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub buffer: RpsResourceDesc__bindgen_ty_1__bindgen_ty_2
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Width of an image resource."]
    pub width: u32,
    #[doc = "< Height of an image resource."]
    pub height: u32,
    pub __bindgen_anon_1: RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Number of mipmap levels."]
    pub mipLevels: u32,
    #[doc = "< Platform independent format to be interpreted by the runtime."]
    pub format: RpsFormat,
    #[doc = "< Number of MSAA samples of an image."]
    pub sampleCount: u32
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Depth of a 3D image resource."]
    pub depth: u32,
    #[doc = "< Number of array layers for a non-3D image resource."]
    pub arrayLayers: u32
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Lower 32 bits of the size of a buffer resource in bytes."]
    pub sizeInBytesLo: u32,
    #[doc = "< Higher 32 bits of the size of a buffer resource in bytes."]
    pub sizeInBytesHi: u32
}
#[doc = " @brief Subsection of a resource from the graphics API perspective."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSubresourceRange {
    #[doc = "< First mipmapping level accessible in the range."]
    pub baseMipLevel: u16,
    #[doc = "< Number of mipmap levels in the range."]
    pub mipLevels: u16,
    #[doc = "< First layer accessible in the range."]
    pub baseArrayLayer: u32,
    #[doc = "< Number of array layers accessible in the range."]
    pub arrayLayers: u32
}
#[doc = " @brief Output resources for writing results of a graphics node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdRenderTargetInfo {
    #[doc = "< Number of render targets used by the node."]
    pub numRenderTargets: u32,
    #[doc = "< Number of MSAA samples."]
    pub numSamples: u32,
    #[doc = "< Depth stencil format or RPS_FORMAT_UNKNOWN if no depth buffer is bound."]
    pub depthStencilFormat: RpsFormat,
    #[doc = " Array of render target formats with one format for each of the numRenderTargets render targets."]
    pub renderTargetFormats: [RpsFormat; 8usize]
}
#[doc = "< Unknown access."]
pub const RpsAccessFlagBits_RPS_ACCESS_UNKNOWN: RpsAccessFlagBits = 0;
#[doc = "< Accessible as an indirect argument buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_INDIRECT_ARGS_BIT: RpsAccessFlagBits = 1;
#[doc = "< Accessible as an index buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_INDEX_BUFFER_BIT: RpsAccessFlagBits = 2;
#[doc = "< Accessible as a vertex buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_VERTEX_BUFFER_BIT: RpsAccessFlagBits = 4;
#[doc = "< Accessible as a constant buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_CONSTANT_BUFFER_BIT: RpsAccessFlagBits = 8;
#[doc = "< Accessible as a shader resource (readonly) view."]
pub const RpsAccessFlagBits_RPS_ACCESS_SHADER_RESOURCE_BIT: RpsAccessFlagBits = 16;
#[doc = "< Accessible as a unordered access (shader readwrite) view."]
pub const RpsAccessFlagBits_RPS_ACCESS_UNORDERED_ACCESS_BIT: RpsAccessFlagBits = 32;
#[doc = "< Accessible as a shading rate image in a Variable Rate Shading"]
pub const RpsAccessFlagBits_RPS_ACCESS_SHADING_RATE_BIT: RpsAccessFlagBits = 64;
#[doc = "< Accessible as a render target view."]
pub const RpsAccessFlagBits_RPS_ACCESS_RENDER_TARGET_BIT: RpsAccessFlagBits = 128;
#[doc = "< Accessible as a readonly depth view."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_READ_BIT: RpsAccessFlagBits = 256;
#[doc = "< Accessible as a writable depth view."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_WRITE_BIT: RpsAccessFlagBits = 512;
#[doc = "< Accessible as a readonly stencil view."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_READ_BIT: RpsAccessFlagBits = 1024;
#[doc = "< Accessible as a writable stencil view."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_WRITE_BIT: RpsAccessFlagBits = 2048;
#[doc = "< Accessible for write as a stream out buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_STREAM_OUT_BIT: RpsAccessFlagBits = 4096;
#[doc = "< Accessible as a copy source."]
pub const RpsAccessFlagBits_RPS_ACCESS_COPY_SRC_BIT: RpsAccessFlagBits = 8192;
#[doc = "< Accessible as a copy target."]
pub const RpsAccessFlagBits_RPS_ACCESS_COPY_DEST_BIT: RpsAccessFlagBits = 16384;
#[doc = "< Accessible as a resolve source."]
pub const RpsAccessFlagBits_RPS_ACCESS_RESOLVE_SRC_BIT: RpsAccessFlagBits = 32768;
#[doc = "< Accessible as a resolve target."]
pub const RpsAccessFlagBits_RPS_ACCESS_RESOLVE_DEST_BIT: RpsAccessFlagBits = 65536;
#[doc = "< Accessible for write (build) as a raytracing acceleration"]
pub const RpsAccessFlagBits_RPS_ACCESS_RAYTRACING_AS_BUILD_BIT: RpsAccessFlagBits = 131072;
#[doc = "< Accessible for read as a raytracing acceleration structure."]
pub const RpsAccessFlagBits_RPS_ACCESS_RAYTRACING_AS_READ_BIT: RpsAccessFlagBits = 262144;
#[doc = "< Accessible as a present source."]
pub const RpsAccessFlagBits_RPS_ACCESS_PRESENT_BIT: RpsAccessFlagBits = 524288;
#[doc = "< Accessible for reads by the CPU."]
pub const RpsAccessFlagBits_RPS_ACCESS_CPU_READ_BIT: RpsAccessFlagBits = 1048576;
#[doc = "< Accessible for writes by the CPU."]
pub const RpsAccessFlagBits_RPS_ACCESS_CPU_WRITE_BIT: RpsAccessFlagBits = 2097152;
#[doc = " Access can be used by a render pass attachment (as render target or depth stencil). Used to distinguish clear-only\n accesses (which may use special clear commands) and render target / depth stencil view accesses."]
pub const RpsAccessFlagBits_RPS_ACCESS_RENDER_PASS: RpsAccessFlagBits = 33554432;
#[doc = " Initial state when entering the node. This allows a view to have a different state at entering and exiting,\n in case the node implementation needs to perform a transition but does not want to transition it back to the\n original state. Not implemented yet."]
pub const RpsAccessFlagBits_RPS_ACCESS_BEFORE_BIT: RpsAccessFlagBits = 67108864;
#[doc = " Final state when exiting the node. This allows a view to have a different state at entering and exiting,\n in case the node implementation needs to perform a transition but does not want to transition it back to the\n original state. Not implemented yet."]
pub const RpsAccessFlagBits_RPS_ACCESS_AFTER_BIT: RpsAccessFlagBits = 134217728;
#[doc = " View is cleared before the current access. Usually used together with other basic access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_CLEAR_BIT: RpsAccessFlagBits = 268435456;
#[doc = " Access does not read existing data so it can be discarded."]
pub const RpsAccessFlagBits_RPS_ACCESS_DISCARD_OLD_DATA_BIT: RpsAccessFlagBits = 536870912;
#[doc = " Access does not care about the ordering with regard to other accesses which also have the\n RPS_ACCESS_RELAXED_ORDER_BIT flag."]
pub const RpsAccessFlagBits_RPS_ACCESS_RELAXED_ORDER_BIT: RpsAccessFlagBits = 1073741824;
#[doc = " Access does not need a resource view to be created, (e.g. via\n ID3D12GraphicsCommandList::CopyResource)."]
pub const RpsAccessFlagBits_RPS_ACCESS_NO_VIEW_BIT: RpsAccessFlagBits = -2147483648;
#[doc = " Accessible as a predication buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_PREDICATION_BIT: RpsAccessFlagBits = 1;
#[doc = " Depth read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH: RpsAccessFlagBits = 768;
#[doc = " Stencil read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL: RpsAccessFlagBits = 3072;
#[doc = " Depth / Stencil read access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL_READ: RpsAccessFlagBits = 1280;
#[doc = " Depth / Stencil write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL_WRITE: RpsAccessFlagBits = 2560;
#[doc = " Depth / Stencil read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL: RpsAccessFlagBits = 3840;
#[doc = " Bitwise OR of all possible GPU writeable access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU_WRITE: RpsAccessFlagBits = 219808;
#[doc = " Bitwise OR of all possible GPU readonly access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU_READONLY: RpsAccessFlagBits = 828767;
#[doc = " Bitwise OR of all possible GPU access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU: RpsAccessFlagBits = 1048575;
#[doc = " Bitwise OR of all possible CPU access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_CPU: RpsAccessFlagBits = 3145728;
#[doc = " Bitwise OR of all GPU / CPU access, excluding decorator flags such as RPS_ACCESS_RELAXED_ORDER_BIT and RPS_ACCESS_NO_VIEW_BIT."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_ACCESS_MASK: RpsAccessFlagBits = 4194303;
#[doc = " @brief Bitflags for resource (view) access attributes.\n\n If specified for a node parameter, it indicates the required resource layout and synchronizations before entering\n and after exiting the node."]
pub type RpsAccessFlagBits = ::std::os::raw::c_int;
#[doc = " @brief Bitmask type for <c><i>RpsAccessFlagBits</i></c>."]
pub type RpsAccessFlags = RpsFlags32;
#[doc = "< No shader stages."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_NONE: RpsShaderStageBits = 0;
#[doc = "< Vertex shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_VS: RpsShaderStageBits = 1;
#[doc = "< Pixel shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_PS: RpsShaderStageBits = 2;
#[doc = "< Geometry shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_GS: RpsShaderStageBits = 4;
#[doc = "< Compute shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_CS: RpsShaderStageBits = 8;
#[doc = "< Hull shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_HS: RpsShaderStageBits = 16;
#[doc = "< Domain shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_DS: RpsShaderStageBits = 32;
#[doc = "< Raytracing shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_RAYTRACING: RpsShaderStageBits = 64;
#[doc = "< Amplification shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_AS: RpsShaderStageBits = 128;
#[doc = "< Mesh shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_MS: RpsShaderStageBits = 256;
#[doc = "< All shader stages."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_ALL: RpsShaderStageBits = 511;
#[doc = " @brief Bitflags for shader stages."]
pub type RpsShaderStageBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsShaderStageBits</i></c>."]
pub type RpsShaderStageFlags = RpsFlags32;
#[doc = " @brief Resource access attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAccessAttr {
    #[doc = "< Access flags."]
    pub accessFlags: RpsAccessFlags,
    #[doc = "< Shader stages allowed for access if applicable."]
    pub accessStages: RpsShaderStageFlags
}
#[doc = "< No semantics."]
pub const RpsSemantic_RPS_SEMANTIC_UNSPECIFIED: RpsSemantic = 0;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_SHADER: RpsSemantic = 1;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PIXEL_SHADER: RpsSemantic = 2;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_GEOMETRY_SHADER: RpsSemantic = 3;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_COMPUTE_SHADER: RpsSemantic = 4;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_HULL_SHADER: RpsSemantic = 5;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DOMAIN_SHADER: RpsSemantic = 6;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RAYTRACING_PIPELINE: RpsSemantic = 7;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_AMPLIFICATION_SHADER: RpsSemantic = 8;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_MESH_SHADER: RpsSemantic = 9;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_LAYOUT: RpsSemantic = 10;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_LAYOUT: RpsSemantic = 11;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_DESC: RpsSemantic = 12;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_BLEND_STATE: RpsSemantic = 13;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RENDER_TARGET_BLEND: RpsSemantic = 14;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_STENCIL_STATE: RpsSemantic = 15;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RASTERIZER_STATE: RpsSemantic = 16;
#[doc = "< Start of the dynamic state semantic enumeration values."]
pub const RpsSemantic_RPS_SEMANTIC_DYNAMIC_STATE_BEGIN: RpsSemantic = 17;
#[doc = " Usage as a viewport. The data type must be <c><i>RpsViewport</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_VIEWPORT: RpsSemantic = 17;
#[doc = " Usage as a scissor rectangle. The data type must be <c><i>RpsRect</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_SCISSOR: RpsSemantic = 18;
#[doc = " Usage as primitive topology. The data must be one of the values specified by <c><i>RpsPrimitiveTopology</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_PRIMITIVE_TOPOLOGY: RpsSemantic = 19;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PATCH_CONTROL_POINTS: RpsSemantic = 20;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PRIMITIVE_STRIP_CUT_INDEX: RpsSemantic = 21;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_BLEND_FACTOR: RpsSemantic = 22;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STENCIL_REF: RpsSemantic = 23;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_BOUNDS: RpsSemantic = 24;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_SAMPLE_LOCATION: RpsSemantic = 25;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_SHADING_RATE: RpsSemantic = 26;
#[doc = " Usage as a color clear value. The data type must be float[4]."]
pub const RpsSemantic_RPS_SEMANTIC_COLOR_CLEAR_VALUE: RpsSemantic = 27;
#[doc = " Usage as a depth clear value. The data type must be float."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_CLEAR_VALUE: RpsSemantic = 28;
#[doc = " Usage as a stencil clear value. The data type must be uint32_t, only the lower 8 bit will be used."]
pub const RpsSemantic_RPS_SEMANTIC_STENCIL_CLEAR_VALUE: RpsSemantic = 29;
#[doc = " Start of the resource binding enumeration values."]
pub const RpsSemantic_RPS_SEMANTIC_RESOURCE_BINDING_BEGIN: RpsSemantic = 30;
#[doc = " Bound as a vertex buffer. The semantic index indicates the vertex buffer binding slot."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_BUFFER: RpsSemantic = 30;
#[doc = " Bound as an index buffer."]
pub const RpsSemantic_RPS_SEMANTIC_INDEX_BUFFER: RpsSemantic = 31;
#[doc = " Bound as an indirect argument buffer."]
pub const RpsSemantic_RPS_SEMANTIC_INDIRECT_ARGS: RpsSemantic = 32;
#[doc = " Bound as an indirect count buffer."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_BUFFER: RpsSemantic = 33;
#[doc = " Bound for write as a stream out buffer. The semantic index indicates the stream out buffer binding slot."]
pub const RpsSemantic_RPS_SEMANTIC_INDIRECT_COUNT: RpsSemantic = 34;
#[doc = " Bound as a render target view. The semantic index indicates the render target slot."]
pub const RpsSemantic_RPS_SEMANTIC_RENDER_TARGET: RpsSemantic = 35;
#[doc = " Bound as a depth stencil view."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_STENCIL_TARGET: RpsSemantic = 36;
#[doc = " Bound as a shading rate image in a Variable Rate Shading (VRS) pass."]
pub const RpsSemantic_RPS_SEMANTIC_SHADING_RATE_IMAGE: RpsSemantic = 37;
#[doc = " Bound as a resolve target. The semantic index indicates the render\n target slot of the resolve source."]
pub const RpsSemantic_RPS_SEMANTIC_RESOLVE_TARGET: RpsSemantic = 38;
#[doc = " User defined resource view binding. This is intended for shader resource views and unordered access views where\n resources are bound to programmable shaders instead of fixed function binding points."]
pub const RpsSemantic_RPS_SEMANTIC_USER_RESOURCE_BINDING: RpsSemantic = 39;
#[doc = "< Number of defined semantics."]
pub const RpsSemantic_RPS_SEMANTIC_COUNT: RpsSemantic = 40;
#[doc = " @brief Graphics resource and argument data usage semantics."]
pub type RpsSemantic = ::std::os::raw::c_uint;
#[doc = " @brief Graph entry and node parameter semantic attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSemanticAttr {
    pub semantic: RpsSemantic,
    pub semanticIndex: u32
}
#[doc = "< No special resource view flags."]
pub const RpsResourceViewFlagBits_RPS_RESOURCE_VIEW_FLAG_NONE: RpsResourceViewFlagBits = 0;
#[doc = "< Resource view is used as a cubemap."]
pub const RpsResourceViewFlagBits_RPS_RESOURCE_VIEW_FLAG_CUBEMAP_BIT: RpsResourceViewFlagBits = 1;
#[doc = " @brief Bitflags for resource view properties."]
pub type RpsResourceViewFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask for <c><i>RpsResourceViewFlagBits</i></c>."]
pub type RpsResourceViewFlags = RpsFlags32;
#[doc = " @brief General resource view.\n\n All shared parameters between buffer and image views."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceView {
    #[doc = "< Resource ID of the viewed resource. RPS_RESOURCE_ID_INVALID indicates a null"]
    pub resourceId: RpsResourceId,
    #[doc = "< Format of the view. RPS_FORMAT_UNKNOWN indicates the format should be inherited from"]
    pub viewFormat: RpsFormat,
    #[doc = "< Temporal layer of the view."]
    pub temporalLayer: u32,
    #[doc = "< Flags for additional view properties."]
    pub flags: RpsResourceViewFlags
}
#[doc = " @brief Image resource view."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsImageView {
    #[doc = "< Base resource view properties."]
    pub base: RpsResourceView,
    #[doc = "< Subresource range of the view."]
    pub subresourceRange: RpsSubresourceRange,
    #[doc = "< Min LOD clamp value of the texture view."]
    pub minLodClamp: f32,
    #[doc = "< 32-bit value for the color component (RGBA channel) mapping of the view."]
    pub componentMapping: u32
}
#[doc = "< Red component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_R: RpsResourceViewComponentMapping = 0;
#[doc = "< Green component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_G: RpsResourceViewComponentMapping = 1;
#[doc = "< Blue component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_B: RpsResourceViewComponentMapping = 2;
#[doc = "< Alpha component"]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_A: RpsResourceViewComponentMapping = 3;
#[doc = "< Constant value of 0."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_ZERO: RpsResourceViewComponentMapping = 4;
#[doc = "< Constant value of 1."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_ONE: RpsResourceViewComponentMapping = 5;
#[doc = "  Specifies the default component mapping (where R, G, B, A components map to R, G, B, A without swizzling).\n  Note this is using 1 byte each channel, different from DX12 default."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_DEFAULT: RpsResourceViewComponentMapping = 50462976;
#[doc = " @brief Resource components or value to map to for component mapping."]
pub type RpsResourceViewComponentMapping = ::std::os::raw::c_uint;
#[doc = " @brief Buffer resource view."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsBufferView {
    #[doc = "< Base view properties."]
    pub base: RpsResourceView,
    #[doc = "< Offset of the buffer range in bytes."]
    pub offset: u64,
    #[doc = "< Size of the buffer range in bytes."]
    pub sizeInBytes: u64,
    #[doc = "< Stride of a structured buffer view. If the API does not support altering per-view"]
    pub stride: u32
}
#[doc = "< Type ID of RpsImageView."]
pub const RpsRuntimeBuiltInTypeIds_RPS_TYPE_IMAGE_VIEW: RpsRuntimeBuiltInTypeIds = 64;
#[doc = "< Type ID of RpsBufferView."]
pub const RpsRuntimeBuiltInTypeIds_RPS_TYPE_BUFFER_VIEW: RpsRuntimeBuiltInTypeIds = 65;
#[doc = " @brief Enumeration of runtime defined built-in type IDs."]
pub type RpsRuntimeBuiltInTypeIds = ::std::os::raw::c_uint;
#[doc = " Screen region to render to."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsViewport {
    #[doc = "< Left offset of the viewport."]
    pub x: f32,
    #[doc = "< Top offset of the viewport."]
    pub y: f32,
    #[doc = "< Width of the viewport."]
    pub width: f32,
    #[doc = "< Height of the viewport."]
    pub height: f32,
    #[doc = "< Minimum Z value of the viewport."]
    pub minZ: f32,
    #[doc = "< Maximum Z value of the viewport."]
    pub maxZ: f32
}
#[doc = " Rectangular geometrical figure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRect {
    #[doc = "< X coordinate of the left edge of the rectangle."]
    pub x: i32,
    #[doc = "< Y coordinate of the top edge of the rectangle."]
    pub y: i32,
    #[doc = "< Width of the rectangle."]
    pub width: i32,
    #[doc = "< Height of the rectangle."]
    pub height: i32
}
#[doc = "< Undefined topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_UNDEFINED: RpsPrimitiveTopology = 0;
#[doc = "< Point list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_POINTLIST: RpsPrimitiveTopology = 1;
#[doc = "< Line list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINELIST: RpsPrimitiveTopology = 2;
#[doc = "< Line strip topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINESTRIP: RpsPrimitiveTopology = 3;
#[doc = "< Triangle list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLELIST: RpsPrimitiveTopology = 4;
#[doc = "< Triangle strip topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: RpsPrimitiveTopology = 5;
#[doc = "< Line list with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: RpsPrimitiveTopology = 10;
#[doc = "< Line strip with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: RpsPrimitiveTopology = 11;
#[doc = "< Triangle list with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: RpsPrimitiveTopology = 12;
#[doc = "< Triangle strip with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: RpsPrimitiveTopology = 13;
#[doc = "< Patch list. The number of control points in the patch list"]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_PATCHLIST: RpsPrimitiveTopology = 14;
#[doc = "< Forces the enumeration to be int32 type. Do not use!!!"]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_FORCE_INT32: RpsPrimitiveTopology = 2147483647;
#[doc = " @brief Primitive topology types.\n\n This maps to common API primitive topology enumerations\n such as `D3D_PRIMITIVE_TOPOLOGY` and `VkPrimitiveTopology`."]
pub type RpsPrimitiveTopology = ::std::os::raw::c_uint;
#[doc = "< Resolve operation outputs the average value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_AVERAGE: RpsResolveMode = 0;
#[doc = "< Resolve operation outputs the minimum value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_MIN: RpsResolveMode = 1;
#[doc = "< Resolve operation outputs the maximum value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_MAX: RpsResolveMode = 2;
#[doc = "< Encoding sampler feedback map (DX12 only)."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_ENCODE_SAMPLER_FEEDBACK: RpsResolveMode = 3;
#[doc = "< Decoding sampler feedback map (DX12 only)."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_DECODE_SAMPLER_FEEDBACK: RpsResolveMode = 4;
pub const RpsResolveMode_RPS_RESOLVE_MODE_FORCE_INT32: RpsResolveMode = 2147483647;
#[doc = " @brief Resolve mode types for built-in resolve node.\n\n Support of the modes is subject to the API backend used."]
pub type RpsResolveMode = ::std::os::raw::c_uint;
#[doc = " @brief Screen regions to render to.\n\n @ingroup RpsRenderGraphCommandRecording"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdViewportInfo {
    #[doc = "< Default render area of the node. Usually deduced from the bound render"]
    pub defaultRenderArea: RpsRect,
    #[doc = "< Number of viewports used by the node."]
    pub numViewports: u32,
    #[doc = "< Number of scissor rectangles used by the node."]
    pub numScissorRects: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsViewport*</i></c> with numViewports"]
    pub pViewports: *const RpsViewport,
    #[doc = "< Pointer to an array of <c><i>const RpsRect*</i></c> with numScissorRects"]
    pub pScissorRects: *const RpsRect
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeDevice_T {
    _unused: [u8; 0]
}
pub type RpsRuntimeDevice = *mut RpsRuntimeDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraph_T {
    _unused: [u8; 0]
}
pub type RpsRenderGraph = *mut RpsRenderGraph_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphBuilder_T {
    _unused: [u8; 0]
}
pub type RpsRenderGraphBuilder = *mut RpsRenderGraphBuilder_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphPhase_T {
    _unused: [u8; 0]
}
pub type RpsRenderGraphPhase = *mut RpsRenderGraphPhase_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSubprogram_T {
    _unused: [u8; 0]
}
pub type RpsSubprogram = *mut RpsSubprogram_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeHeap_T {
    pub ptr: *mut ::std::os::raw::c_void
}
pub type RpsRuntimeHeap = RpsRuntimeHeap_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeResource_T {
    pub ptr: *mut ::std::os::raw::c_void
}
pub type RpsRuntimeResource = RpsRuntimeResource_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeCommandBuffer_T {
    pub ptr: *mut ::std::os::raw::c_void
}
pub type RpsRuntimeCommandBuffer = RpsRuntimeCommandBuffer_T;
#[doc = " @brief Function parameter attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParamAttr {
    #[doc = "< Access attribute of the parameter."]
    pub access: RpsAccessAttr,
    #[doc = "< Semantic attribute of the parameter."]
    pub semantic: RpsSemanticAttr
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParamAttrList_T {
    _unused: [u8; 0]
}
pub type RpsParamAttrList = *mut RpsParamAttrList_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNodeAttrList_T {
    _unused: [u8; 0]
}
pub type RpsNodeAttrList = *mut RpsNodeAttrList_T;
#[doc = " No schedule flag bits are specified. Default options are used. When used as\n RpsRenderGraphUpdateInfo::scheduleFlags, the RpsRenderGraphCreateInfo::scheduleInfo::scheduleFlags specified\n at render graph creation time are used instead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_UNSPECIFIED: RpsScheduleFlagBits = 0;
#[doc = " Command nodes are kept in the program order."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_KEEP_PROGRAM_ORDER_BIT: RpsScheduleFlagBits = 1;
#[doc = " Schedules in favor of reducing total GPU memory usage. Possible strategies include minimizing transient resource\n lifetimes and agressive aliasing. This may increase the number of barriers generated."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_PREFER_MEMORY_SAVING_BIT: RpsScheduleFlagBits = 2;
#[doc = " Schedules commands randomly (without changing program logic). Mostly useful for testing purposes. Applications\n should normally avoid using this flag for end-user scenarios. If RPS_SCHEDULE_KEEP_PROGRAM_ORDER_BIT is set,\n this flag will have no effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_RANDOM_ORDER_BIT: RpsScheduleFlagBits = 4;
#[doc = " Avoids alternating between graphics and compute work on the same queue. This can help for some architectures\n where switching between graphics and compute produces extra overhead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_MINIMIZE_COMPUTE_GFX_SWITCH_BIT: RpsScheduleFlagBits = 8;
#[doc = " Disables dead code elimination optimization. By default, RPS removes nodes that have no visible effect (Not\n contributing to modification of external, temporal, persistent or CPU resources). This flag disables this\n optimization."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DISABLE_DEAD_CODE_ELIMINATION_BIT: RpsScheduleFlagBits = 16;
#[doc = " Disables work pipelining based on the workload type."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_DISABLE_BIT: RpsScheduleFlagBits = 32;
#[doc = " Performs aggressive work pipelining based on the workload type. If\n RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_DISABLE_BIT is set, this flag will have not effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_AGGRESSIVE_BIT: RpsScheduleFlagBits = 64;
#[doc = " Includes split barriers where appropriate."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_ALLOW_SPLIT_BARRIERS_BIT: RpsScheduleFlagBits = 65536;
#[doc = " Reserved for future use. Avoids rescheduling if possible and uses the existing schedule instead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_AVOID_RESCHEDULE_BIT: RpsScheduleFlagBits = 131072;
#[doc = " Reserved for future use. Allows work to overlap between multiple frames."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_ALLOW_FRAME_OVERLAP_BIT: RpsScheduleFlagBits = 2097152;
#[doc = " Reserved for future use. Tries to use render pass transitions instead of standalone transition nodes when\n possible. If RPS_SCHEDULE_DISABLE_RENDERPASS_TRANSITIONS_BIT is set, this flag will have no effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_PREFER_RENDERPASS_TRANSITIONS_BIT: RpsScheduleFlagBits = 4194304;
#[doc = " Reserved for future use. Uses standalone transition nodes instead of render pass transitions."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DISABLE_RENDERPASS_TRANSITIONS_BIT: RpsScheduleFlagBits = 8388608;
#[doc = " Uses default options. This is identical to RPS_SCHEDULE_UNSPECIFIED in most cases, except when used as\n RpsRenderGraphUpdateInfo::scheduleFlags, instead using the default options regardless of\n RpsRenderGraphCreateInfo::scheduleInfo::scheduleFlags. This default behavior is a baseline set of criteria used\n for scheduling to which these flags can add additional ones."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT: RpsScheduleFlagBits = 1073741824;
#[doc = " Pioritizes application performance over a lower memory footprint."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT_PERFORMANCE: RpsScheduleFlagBits = 1073741824;
#[doc = " Prioritizes a lower memory footprint over performance."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT_MEMORY: RpsScheduleFlagBits = 2;
#[doc = " @brief Bitflags for scheduling behavior."]
pub type RpsScheduleFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsScheduleFlagBits</i></c>."]
pub type RpsScheduleFlags = RpsFlags32;
#[doc = "< No diagnostic mode enabled."]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_NONE: RpsDiagnosticFlagBits = 0;
#[doc = "< Dumps the resources and commands of a render graph"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_PRE_SCHEDULE_DUMP: RpsDiagnosticFlagBits = 1;
#[doc = "< Dumps the commands of the render graph after"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_POST_SCHEDULE_DUMP: RpsDiagnosticFlagBits = 2;
#[doc = "< Dumps the directed acyclic graph of nodes defined"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_DAG_DUMP: RpsDiagnosticFlagBits = 4;
#[doc = "< Inserts source code location debug data for"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_SOURCE_LOCATION: RpsDiagnosticFlagBits = 8;
#[doc = "< Sets resource names as debug names in the graphics"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_RUNTIME_DEBUG_NAMES: RpsDiagnosticFlagBits = 16;
#[doc = "< Enable all flags."]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_ALL: RpsDiagnosticFlagBits = 31;
#[doc = " @brief Bitflags for enabling diagnostic systems."]
pub type RpsDiagnosticFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsDiagnosticFlagBits</i></c>."]
pub type RpsDiagnosticFlags = RpsFlags32;
#[doc = "< No special properties."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_FLAG_NONE: RpsRenderGraphFlagBits = 0;
#[doc = "< Disallows unbound nodes if no default callback is set."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_DISALLOW_UNBOUND_NODES_BIT: RpsRenderGraphFlagBits = 1;
#[doc = "< Disables GPU memory aliasing."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_NO_GPU_MEMORY_ALIASING: RpsRenderGraphFlagBits = 2;
#[doc = " @brief Bitflags for special render graph properties."]
pub type RpsRenderGraphFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRenderGraphFlagBits</i></c>."]
pub type RpsRenderGraphFlags = RpsFlags32;
#[doc = "< No node declaration properties."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_FLAG_NONE: RpsNodeDeclFlagBits = 0;
#[doc = "< Node requires a queue with graphics capabilites."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_GRAPHICS_BIT: RpsNodeDeclFlagBits = 1;
#[doc = "< Node requires a queue with compute capabilities."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_COMPUTE_BIT: RpsNodeDeclFlagBits = 2;
#[doc = "< Node requires a queue with copy capabilities."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_COPY_BIT: RpsNodeDeclFlagBits = 4;
#[doc = "< Node prefers to be executed as a render pass if the API backend"]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_PREFER_RENDER_PASS: RpsNodeDeclFlagBits = 8;
#[doc = "< Node prefers to be executed asynchronously."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_PREFER_ASYNC: RpsNodeDeclFlagBits = 16;
#[doc = " @brief Bitflags for properties of a render graph node declaration.\n\n These are e.g. required queue type, async preferences, etc. All usages of a node will use the same set of\n properties the node was declared with."]
pub type RpsNodeDeclFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsNodeDeclFlagBits</i></c>."]
pub type RpsNodeDeclFlags = RpsFlags32;
#[doc = "< No bit flags."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_NONE: RpsParameterFlagBits = 0;
#[doc = "< Node parameter is an output parameter."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_OUT_BIT: RpsParameterFlagBits = 1;
#[doc = "< Node parameter is optional."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_OPTIONAL_BIT: RpsParameterFlagBits = 2;
#[doc = "< Node parameter is an RPS resource."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_RESOURCE_BIT: RpsParameterFlagBits = 4;
#[doc = " @brief Bitflags for decorating node parameters."]
pub type RpsParameterFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsParameterFlagBits</i></c>."]
pub type RpsParameterFlags = u32;
#[doc = " No callback properties."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_FLAG_NONE: RpsCmdCallbackFlagBits = 0;
#[doc = " The command callback will record  command buffer in a multi-threaded way. This may change the render pass setup\n behavior as required by some graphics APIs."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_MULTI_THREADED_BIT: RpsCmdCallbackFlagBits = 1;
#[doc = " Skips default render target / depth stencil buffer setup, even if any were specified in the node parameter\n semantics."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_RENDER_TARGETS_BIT: RpsCmdCallbackFlagBits = 2;
#[doc = " Skips viewport and scissor rect setup during command node setup. Used when the command callback will do the\n setup instead."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_VIEWPORT_BIT: RpsCmdCallbackFlagBits = 4;
#[doc = " Skips render state & resource binding setup other than render targets (including depth stencil buffer) and\n viewport (including scissor rects)."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_STATE_SETUP_BIT: RpsCmdCallbackFlagBits = 8;
#[doc = " @brief Bitflags for command callback properties.\n\n Different calls of the same node may use different sets of properties."]
pub type RpsCmdCallbackFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsCmdCallbackFlagBits</i></c>."]
pub type RpsCmdCallbackFlags = RpsFlags32;
#[doc = " @brief Signature of render graph node callbacks.\n\n @param pContext                     Context for the command callback."]
pub type PFN_rpsCmdCallback = ::std::option::Option<unsafe extern "C" fn(pContext: *const RpsCmdCallbackContext)>;
#[doc = " @brief Command callback with usage parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdCallback {
    #[doc = "< Pointer to a callback function."]
    pub pfnCallback: PFN_rpsCmdCallback,
    #[doc = "< User context to be passed to the callback."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Flags for the callback."]
    pub flags: RpsCmdCallbackFlags
}
#[doc = " @brief Parameters for describing a node call parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParameterDesc {
    #[doc = "< Type info of the parameter."]
    pub typeInfo: RpsTypeInfo,
    #[doc = "< Number of array elements for this parameter. 0 indicates not an array (single"]
    pub arraySize: u32,
    #[doc = "< Pointer to a runtime defined structure with attributes of the parameter."]
    pub attr: RpsConstant,
    #[doc = "< Null terminated string with the name of the parameter."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Parameter type flags."]
    pub flags: RpsParameterFlags
}
#[doc = " @brief Parameters for describing a render graph node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNodeDesc {
    #[doc = "< Flags for the type of render graph node."]
    pub flags: RpsNodeDeclFlags,
    #[doc = "< Number of parameters used in the callback."]
    pub numParams: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsParameterDesc</i></c> with"]
    pub pParamDescs: *const RpsParameterDesc,
    #[doc = "< Null terminated string with the name of the callback."]
    pub name: *const ::std::os::raw::c_char
}
#[doc = " @brief Parameters for describing a render graph signature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphSignatureDesc {
    #[doc = "< Number of parameters in the signature."]
    pub numParams: u32,
    #[doc = "< Number of node descriptions in the signature."]
    pub numNodeDescs: u32,
    #[doc = "< Number of resources in the parameters of the signature. Array parameters"]
    pub maxExternalResources: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsParameterDesc</i></c> with"]
    pub pParamDescs: *const RpsParameterDesc,
    #[doc = "< Pointer to an array of <c><i>const RpsNodeDesc</i></c> with numNodeDescs"]
    pub pNodeDescs: *const RpsNodeDesc,
    #[doc = "< Null terminated string with the name of the render graph."]
    pub name: *const ::std::os::raw::c_char
}
extern "C" {
    #[doc = " @brief Reports an error from a command callback context.\n\n @param pContext                         Pointer to the context. Must be the primary context (passed to the command\n                                         callback as argument). This function fails if the context is a secondary\n                                         context (created via rpsCmdCloneContext). Must not be NULL.\n\n @param errorCode                        Error code for the type of error to report. For errorCode == RPS_OK, this\n                                         function does nothing.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdCallbackReportError(pContext: *const RpsCmdCallbackContext, errorCode: RpsResult) -> RpsResult;
}
#[doc = "< No node instance properties."]
pub const RpsNodeFlagBits_RPS_NODE_FLAG_NONE: RpsNodeFlagBits = 0;
#[doc = "< Node prefers to be executed asynchronously."]
pub const RpsNodeFlagBits_RPS_NODE_PREFER_ASYNC: RpsNodeFlagBits = 2;
#[doc = " @brief Bitflags for node instance properties."]
pub type RpsNodeFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for  <c><i>RpsNodeFlagBits</i></c> of properties for a render graph node instance.\n\n While RpsNodeDeclFlags apply to all instances which share the same node declaration, RpsNodeFlags apply to one\n specific node instance."]
pub type RpsNodeFlags = RpsFlags32;
#[doc = " @brief Signature of functions for render graph building.\n\n @param hBuilder                             Handle to the render graph builder to use.\n @param pArgs                                Pointer to an array of <c><i>RpsConstant</i></c> with numArgs constant\n                                             arguments to use for building. Must not be NULL if numArgs != 0.\n @param numArgs                              Number of constant arguments to use for building.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphBuild = ::std::option::Option<unsafe extern "C" fn(hBuilder: RpsRenderGraphBuilder, pArgs: *const RpsConstant, numArgs: u32) -> RpsResult>;
#[doc = " @brief Parameters for updating a render graph.\n\n @relates RpsRenderGraph"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphUpdateInfo {
    #[doc = " Index of the current frame to be recorded after the update."]
    pub frameIndex: u64,
    #[doc = " Index of the last frame that finished executing on the GPU. Used for resource lifetime management."]
    pub gpuCompletedFrameIndex: u64,
    #[doc = " Flags for scheduling behavior. Used for overriding flags specified at creation."]
    pub scheduleFlags: RpsScheduleFlags,
    #[doc = " Flags for enabling diagnostics systems during the render graph update."]
    pub diagnosticFlags: RpsDiagnosticFlags,
    #[doc = " Number of arguments to pass to the entry. Passing less than the number of values from the render graph entry\n updates only the first numArgs arguments and does not touch any other argument."]
    pub numArgs: u32,
    #[doc = " Pointer to an array of <c><i>RpsConstant</i></c> with numArgs constant arguments to pass to the entry.\n Must not be NULL if numArgs != 0."]
    pub ppArgs: *const RpsConstant,
    #[doc = " Pointer to an array of <c><i>const RpsRuntimeResource* const</i></c> with pointers to externally managed\n resources used in the render graph. Resource arguments in ppArgs have a corresponding runtime resource (or\n array) in ppArgResources, at the same index. If e.g. {&backBufferResourceDescription, value} is passed for\n ppArgs, ppArgResources[0] would have to point to the corresponding <c><i>RpsRuntimeResource</i></c> of the\n backbuffer."]
    pub ppArgResources: *const *const RpsRuntimeResource,
    #[doc = " Pointer to a function for starting the render graph building process."]
    pub pfnBuildCallback: PFN_rpsRenderGraphBuild,
    #[doc = " Pointer to a random number generator."]
    pub pRandomNumberGenerator: *const RpsRandomNumberGenerator
}
#[doc = " @brief Signature of functions for executing a render graph phase.\n\n @param hRenderGraph             Handle to the render graph to execute the phase for.\n @param pUpdateInfo              Pointer to update parameters.\n @param phase                    Handle to the render graph phase object.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphPhaseRun =
    ::std::option::Option<unsafe extern "C" fn(hRenderGraph: RpsRenderGraph, pUpdateInfo: *const RpsRenderGraphUpdateInfo, phase: RpsRenderGraphPhase) -> RpsResult>;
#[doc = " @brief Signature of functions for destroying a render graph phase object.\n\n @param phase                    Handle to the render graph phase object.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphPhaseDestroy = ::std::option::Option<unsafe extern "C" fn(phase: RpsRenderGraphPhase) -> RpsResult>;
#[doc = " @brief Parameters of a render graph processing phase."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphPhaseInfo {
    #[doc = "< Handle to the render graph phase object."]
    pub hPhase: RpsRenderGraphPhase,
    #[doc = "< Pointer to a function for executing the render graph phase."]
    pub pfnRun: PFN_rpsRenderGraphPhaseRun,
    #[doc = "< Pointer to a function for destroying the render graph phase."]
    pub pfnDestroy: PFN_rpsRenderGraphPhaseDestroy
}
#[doc = " @brief Parameters of a memory type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsMemoryTypeInfo {
    #[doc = "< Default size for creating a heap of this type."]
    pub defaultHeapSize: u64,
    #[doc = "< Minimum alignment for heaps of this memory type in bytes."]
    pub minAlignment: u32
}
#[doc = " @brief Required parameters for a GPU memory allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsGpuMemoryRequirement {
    #[doc = "< Size of the allocation in bytes."]
    pub size: u64,
    #[doc = "< Minimum alignment required by the allocation in bytes."]
    pub alignment: u32,
    #[doc = "< Index for the type of memory the allocation should be created from. API backend"]
    pub memoryTypeIndex: RpsIndex32
}
#[doc = " @brief Type for heap identifiers.\n\n Internally, these are used as simple indices."]
pub type RpsHeapId = RpsIndex32;
#[doc = " @brief Parameters of a resource placement inside a heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsHeapPlacement {
    #[doc = "< ID of the heap in the render graph."]
    pub heapId: RpsHeapId,
    #[doc = "< Offset of the resource placement inside the heap in bytes."]
    pub offset: u64
}
#[doc = " @brief Parameters of a runtime resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsRuntimeResourceInfo {
    #[doc = "< Handle to the resource created by the API backend."]
    pub hResource: RpsRuntimeResource,
    #[doc = "< Resource description."]
    pub resourceDesc: RpsResourceDesc,
    #[doc = "< Number of subresources in the entire resource."]
    pub numSubresources: u32,
    #[doc = "< Range spanning all subresources."]
    pub fullRange: RpsSubresourceRange,
    #[doc = "< ID of the heap its memory is placed in."]
    pub heapId: RpsHeapId,
    #[doc = "< Allocation parameters of the resource."]
    pub allocInfo: RpsGpuMemoryRequirement
}
#[doc = "< No capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_NONE: RpsQueueFlagBits = 0;
#[doc = "< Graphics capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_GRAPHICS: RpsQueueFlagBits = 1;
#[doc = "< Compute capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_COMPUTE: RpsQueueFlagBits = 2;
#[doc = "< Copy capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_COPY: RpsQueueFlagBits = 4;
#[doc = " @brief Bitflags for queue capabilities."]
pub type RpsQueueFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsQueueFlagBits</i></c>."]
pub type RpsQueueFlags = RpsFlags32;
#[doc = " @brief Parameters for creating a custom GPU memory heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpCreateHeapArgs {
    #[doc = "< Index of the type of memory the allocation should be created from. API"]
    pub memoryTypeIndex: u32,
    #[doc = "< Size of the heap in bytes."]
    pub size: usize,
    #[doc = "< Alignment of the heap in bytes."]
    pub alignment: usize,
    #[doc = "< Null terminated string with the debug name of the heap. Passing NULL sets no name."]
    pub debugName: *const ::std::os::raw::c_char,
    #[doc = "< Pointer to a handle in which the heap is returned. Must not be NULL."]
    pub phHeap: *mut RpsRuntimeHeap
}
#[doc = " @brief Parameters for destroying an array of runtime GPU memory heaps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpDestroyHeapArgs {
    #[doc = "< Number of heaps to destroy."]
    pub numHeaps: u32,
    #[doc = "< Pointer to an array of <c><i>RpsRuntimeHeap</i></c> with numHeaps heap handles to"]
    pub phRtHeaps: *mut RpsRuntimeHeap
}
#[doc = " @brief Parameters for creating a runtime resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsRuntimeOpCreateResourceArgs {
    #[doc = "< ID of the resource declaration."]
    pub resourceId: RpsResourceId,
    #[doc = "< Resource description."]
    pub desc: RpsResourceDesc,
    #[doc = "< Umodified resource description as originally defined by the user."]
    pub originalDesc: RpsVariable,
    #[doc = "< Default value for clearing the resource."]
    pub clearValue: RpsClearValue,
    #[doc = "< Allocation requirements."]
    pub allocRequirement: RpsGpuMemoryRequirement,
    #[doc = "< Allocation placement parameters."]
    pub allocPlacement: RpsHeapPlacement,
    #[doc = "< Combined accesses of the resource."]
    pub allAccesses: RpsAccessAttr,
    #[doc = "< Inital access of the resource in a frame."]
    pub initialAccess: RpsAccessAttr,
    #[doc = "< Number of mutable formats the resource can be used with."]
    pub numMutableFormats: u32,
    #[doc = "< Pointer to an array of <c><i>RpsFormat</i></c> with numMutableFormats"]
    pub mutableFormats: *mut RpsFormat,
    #[doc = "< Indicator for a formatted texel buffer (maps to"]
    pub bBufferFormattedWrite: RpsBool,
    #[doc = "< Indicator for a formatted texel buffer (maps to"]
    pub bBufferFormattedRead: RpsBool,
    #[doc = "< Pointer to a handle to the runtime resource to be returned."]
    pub phRuntimeResource: *mut RpsRuntimeResource
}
#[doc = " @brief Parameters for destroying an array of runtime resources."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpDestroyResourceArgs {
    #[doc = "< Type of the resources."]
    pub type_: RpsResourceType,
    #[doc = "< Number of resources."]
    pub numResources: u32,
    #[doc = "< Pointer to an array of <c><i>RpsRuntimeResource</i></c> with"]
    pub phRuntimeResources: *const RpsRuntimeResource
}
#[doc = " @brief Parameters for creating the used defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpCreateNodeUserResourcesArgs {
    #[doc = "< User defined context to pass to the node."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to an array of <c><i>void*</i></c> with numArgs arguments to be passed to the"]
    pub ppArgs: *const *mut ::std::os::raw::c_void,
    #[doc = "< Number of arguments of the node."]
    pub numArgs: u32,
    #[doc = "< User defined node tag to be used for node associations."]
    pub nodeTag: u32
}
#[doc = "< Beginning of a marker region."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_BEGIN: RpsRuntimeDebugMarkerMode = 0;
#[doc = "< Standalone label."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_LABEL: RpsRuntimeDebugMarkerMode = 1;
#[doc = "< End of a marker region."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_END: RpsRuntimeDebugMarkerMode = 2;
#[doc = " @brief Debug marker modes."]
pub type RpsRuntimeDebugMarkerMode = ::std::os::raw::c_uint;
#[doc = "< No special behavior."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_FLAG_NONE: RpsRuntimeRenderPassFlagBits = 0;
#[doc = "< Suspending render pass in D3D12."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_SUSPENDING: RpsRuntimeRenderPassFlagBits = 1;
#[doc = "< Resuming render pass in D3D12."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_RESUMING: RpsRuntimeRenderPassFlagBits = 2;
#[doc = "< Render pass executes secondary command"]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_EXECUTE_SECONDARY_COMMAND_BUFFERS: RpsRuntimeRenderPassFlagBits = 4;
#[doc = "< Current render pass is on a secondary"]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_SECONDARY_COMMAND_BUFFER: RpsRuntimeRenderPassFlagBits = 8;
#[doc = " @brief Bitflags for render pass behavior."]
pub type RpsRuntimeRenderPassFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for  <c><i>RpsRuntimeRenderPassFlagBits</i></c>."]
pub type RpsRuntimeRenderPassFlags = RpsFlags32;
#[doc = " @brief Parameters for recording a debug marker command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpRecordDebugMarkerArgs {
    #[doc = "< Handle to the runtime commmand buffer to record the command for."]
    pub hCommandBuffer: RpsRuntimeCommandBuffer,
    #[doc = "< User context passed as RpsRenderGraphRecordCommandInfo::pUserContext."]
    pub pUserRecordContext: *mut ::std::os::raw::c_void,
    #[doc = "< Marker mode."]
    pub mode: RpsRuntimeDebugMarkerMode,
    #[doc = "< String payload of the marker. Ignored for"]
    pub text: *const ::std::os::raw::c_char
}
#[doc = " @brief Parameters for setting a resource debug name."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpSetDebugNameArgs {
    #[doc = "< Handle to the runtime resource. Only support resource objects at the moment."]
    pub hResource: RpsRuntimeResource,
    #[doc = "< Resource type."]
    pub resourceType: RpsResourceType,
    #[doc = "< Null terminated string with the resource name."]
    pub name: *const ::std::os::raw::c_char
}
#[doc = " @brief Signature of functions for defining an array of render graph phases.\n\n @param pUserContext                     User defined context.\n @param hRenderGraph                     Handle to the render graph to build the phases for.\n                                         Must not be RPS_NULL_HANDLE.\n @param ppPhaseInfo                      Pointer to an array of <c><i>const RpsRenderGraphPhaseInfo*</i></c> in which\n                                         *pNumPhases render graph phase objects are returned. Must not be NULL.\n @param pNumPhases                       Pointer to write the number of created phases to. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeDeviceBuildRenderGraphPhases = ::std::option::Option<
    unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, hRenderGraph: RpsRenderGraph, ppPhaseInfo: *mut *const RpsRenderGraphPhaseInfo, pNumPhases: *mut u32) -> RpsResult
>;
#[doc = " @brief Signature of functions for destroying a runtime device.\n\n @param pUserContext                     User defined context."]
pub type PFN_rpsRuntimeDeviceDestroy = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Signature of functions for creating a runtime heap.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeCreateHeap = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpCreateHeapArgs) -> RpsResult>;
#[doc = " @brief Signature of functions for destroying runtime heaps.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap destruction parameters. Must not be NULL."]
pub type PFN_rpsRuntimeDestroyHeap = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpDestroyHeapArgs)>;
#[doc = " @brief Signature of functions for creating a runtime resource.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to resource creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeCreateResource = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpCreateResourceArgs) -> RpsResult>;
#[doc = " @brief Signature of functions for destroying runtime resources.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap destruction parameters. Must not be NULL."]
pub type PFN_rpsRuntimeDestroyResource = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpDestroyResourceArgs)>;
#[doc = " @brief Creates the user defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to node arg creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeOpCreateNodeUserResources =
    ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpCreateNodeUserResourcesArgs) -> RpsResult>;
#[doc = " @brief Destroys the user defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports.\n\n @param pUserContext                     User defined context."]
pub type PFN_rpsRuntimeOpDestroyNodeUserResources = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Signature of functions for recording runtime debug markers.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to debug marker parameters. Must not be NULL."]
pub type PFN_rpsRuntimeOpRecordDebugMarker = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpRecordDebugMarkerArgs)>;
#[doc = " @brief Signature of functions for setting runtime debug names.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to debug name parameters. Must not be NULL."]
pub type PFN_rpsRuntimeOpSetDebugName = ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void, pArgs: *const RpsRuntimeOpSetDebugNameArgs)>;
#[doc = " @brief Callback functions of a runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeCallbacks {
    #[doc = "< Render graph phase build callback."]
    pub pfnBuildRenderGraphPhases: PFN_rpsRuntimeDeviceBuildRenderGraphPhases,
    #[doc = "< Runtime destruction callback."]
    pub pfnDestroyRuntime: PFN_rpsRuntimeDeviceDestroy,
    #[doc = "< Heap creation callback."]
    pub pfnCreateHeap: PFN_rpsRuntimeCreateHeap,
    #[doc = "< Heap destruction callback."]
    pub pfnDestroyHeap: PFN_rpsRuntimeDestroyHeap,
    #[doc = "< Resource creation callback."]
    pub pfnCreateResource: PFN_rpsRuntimeCreateResource,
    #[doc = "< Resource destruction callback."]
    pub pfnDestroyResource: PFN_rpsRuntimeDestroyResource,
    #[doc = "< Node resource creation callback."]
    pub pfnCreateNodeResources: PFN_rpsRuntimeOpCreateNodeUserResources,
    #[doc = "< Node argument destruction callback."]
    pub pfnDestroyNodeResources: PFN_rpsRuntimeOpDestroyNodeUserResources,
    #[doc = "< Debug marker recording callback."]
    pub pfnRecordDebugMarker: PFN_rpsRuntimeOpRecordDebugMarker,
    #[doc = "< Debug name setting callback."]
    pub pfnSetDebugName: PFN_rpsRuntimeOpSetDebugName
}
#[doc = " @brief Parameters for creating a runtime device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeDeviceCreateInfo {
    #[doc = "< User defined context to be passed to the callback functions."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Callback functions."]
    pub callbacks: RpsRuntimeCallbacks
}
#[doc = " @brief Parameters for creating a dummy runtime device.\n\n A <c><i>NullRuntimeDevice</i></c> is a default implementation of the RuntimeDevice interface without any real GPU\n device associated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNullRuntimeDeviceCreateInfo {
    #[doc = "< Pointer to parameters for creating the core device"]
    pub pDeviceCreateInfo: *const RpsDeviceCreateInfo,
    #[doc = "< Pointer to parameters for creating the runtime device."]
    pub pRuntimeCreateInfo: *const RpsRuntimeDeviceCreateInfo
}
extern "C" {
    #[doc = " @brief Creates a dummy runtime.\n\n For more info see <c><i>RpsNullRuntimeDeviceCreateInfo</i></c>.\n\n @param pCreateInfo                                      Pointer to parameters for creating a dummy runtime. Passing\n                                                         NULL uses default parameters for creation instead.\n @param phDevice                                         Pointer a handle in which the device is returned. Must\n                                                         not be NULL.\n\n @returns                                                Result code of the operation. See <c><i>RpsResult</i></c>\n                                                         for more info."]
    pub fn rpsNullRuntimeDeviceCreate(pCreateInfo: *const RpsNullRuntimeDeviceCreateInfo, phDevice: *mut RpsDevice) -> RpsResult;
}
#[doc = " Parameters for creating an RPS program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsProgramCreateInfo {
    #[doc = " Pointer to signature parameters for the program entry. If hRpslEntryPoint is specified, this parameter will be\n ignored and the signature will be taken from the RpslEntry definition.\n Must not be NULL if hRpslEntryPoint == RPS_NULL_HANDLE."]
    pub pSignatureDesc: *const RpsRenderGraphSignatureDesc,
    #[doc = " Handle to the program entry point."]
    pub hRpslEntryPoint: RpsRpslEntry,
    #[doc = " Default node callback. Used when a node is called for which no implementation is bound."]
    pub defaultNodeCallback: RpsCmdCallback
}
extern "C" {
    #[doc = " @brief Gets the signature description of an RPSL entry point.\n\n @param hRpslEntry               Handle to the RPSL entry point.\n @param pDesc                    Pointer in which the signature description is returned. Must not be NULL.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRpslEntryGetSignatureDesc(hRpslEntry: RpsRpslEntry, pDesc: *mut RpsRenderGraphSignatureDesc) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Creates a subprogram.\n\n @param hDevice                  Handle to the device to use for creation.\n @param pCreateInfo              Pointer to the creation parameters. Must not be NULL.\n @param phProgram                Pointer to a handle in which the subprogram is returned. Must not be NULL.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramCreate(hDevice: RpsDevice, pCreateInfo: *const RpsProgramCreateInfo, phProgram: *mut RpsSubprogram) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Destroys a subprogram instance.\n\n @param hProgram                 Handle to the subprogram object."]
    pub fn rpsProgramDestroy(hProgram: RpsSubprogram);
}
extern "C" {
    #[doc = " @brief Binds a command node callback to a node declaration specified by name.\n\n Node instances generated from the program with the specified node declaration will call the same callback during\n render graph command recording.\n\n @param hProgram                 Handle to the program to bind a node for.\n @param name                     Null terminated string with the name of the node.\n @param pCallback                Pointer to callback parameters. Passing NULL uses default callback parameters.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramBindNodeCallback(hProgram: RpsSubprogram, name: *const ::std::os::raw::c_char, pCallback: *const RpsCmdCallback) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Binds a subprogram to a node declaration specified by name.\n\n The subprogram will be executed during render graph update as if inlined into the parent program.\n During render graph command recording, node instances generated from the subprogram will call the subprogram node\n callbacks bindings. Subprograms can be nested recursively.\n\n @param hProgram                 Handle to the program to bind the subprogram to.\n @param name                     Null terminated string with the name of the node.\n @param hSubprogram              Handle to the subprogram to bind.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramBindNodeSubprogram(hProgram: RpsSubprogram, name: *const ::std::os::raw::c_char, hSubprogram: RpsSubprogram) -> RpsResult;
}
#[doc = " @brief Parameters for creating a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo {
    pub scheduleInfo: RpsRenderGraphCreateInfo__bindgen_ty_1,
    pub memoryInfo: RpsRenderGraphCreateInfo__bindgen_ty_2,
    #[doc = "< Creation parameters for the main entry RPS program."]
    pub mainEntryCreateInfo: RpsProgramCreateInfo,
    #[doc = "< Flags for render graph properties."]
    pub renderGraphFlags: RpsRenderGraphFlags,
    #[doc = " Number of render graph phase objects used by the render graph."]
    pub numPhases: u32,
    #[doc = " Pointer to an array of <c><i>const RpsRenderGraphPhaseInfo</i></c> with numPhases render graph phase objects\n used by the render graph. If null, RPS uses the runtime specified default pipeline to process the render graph."]
    pub pPhases: *const RpsRenderGraphPhaseInfo
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo__bindgen_ty_1 {
    #[doc = "< Flags for scheduling behavior."]
    pub scheduleFlags: RpsScheduleFlags,
    #[doc = "< Number of queues avaiblable to the render graph. If 0, RPS assumes there"]
    pub numQueues: u32,
    #[doc = "< Pointer to an array of <c><i>RpsQueueFlags</i></c> with numQueues queue"]
    pub pQueueInfos: *const RpsQueueFlags
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo__bindgen_ty_2 {
    #[doc = "< Number of memory heaps available to the render graph."]
    pub numHeaps: u32,
    #[doc = "< Pointer to an array of <c><i>uint32_t</i></c> numHeaps memory sizes as"]
    pub heapBudgetMiBs: *const u32
}
extern "C" {
    #[doc = " @brief Creates a render graph.\n\n @param hDevice                              Handle to the device to use for creation. Must not be RPS_NULL_HANDLE.\n @param pCreateInfo                          Pointer to creation parameters. Must not be NULL.\n @param phRenderGraph                        Pointer a handle in which the render graph is returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphCreate(hDevice: RpsDevice, pCreateInfo: *const RpsRenderGraphCreateInfo, phRenderGraph: *mut RpsRenderGraph) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Updates a render graph.\n\n @param hRenderGraph                         Handle to the render graph to update. Must not be RPS_NULL_HANDLE.\n @param pUpdateInfo                          Pointer to update parameters. Must not be NULL.\n\n @returns                                    RpsResult indicating potential errors during the execution. See\n                                             <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphUpdate(hRenderGraph: RpsRenderGraph, pUpdateInfo: *const RpsRenderGraphUpdateInfo) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Destroys a render graph.\n\n @param hRenderGraph                         Handle to the render graph object to destroy."]
    pub fn rpsRenderGraphDestroy(hRenderGraph: RpsRenderGraph);
}
extern "C" {
    #[doc = " @brief Allocates memory from a render graph builder.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param size                     Required size of the allocation.\n\n @returns                        Pointer to the allocated memory if the allocation was successful, NULL otherwise.\n                                 Only valid until the next render graph update."]
    pub fn rpsRenderGraphAllocateData(hRenderGraphBuilder: RpsRenderGraphBuilder, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Allocates memory from a render graph builder with alignment requirements.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param size                     Required size of the allocation.\n @param alignment                Minimum alignment requirement of the allocation in bytes.\n\n @returns                        Pointer to the allocated memory if allocation was successful, NULL otherwise.\n                                 Only valid until the next render graph update."]
    pub fn rpsRenderGraphAllocateDataAligned(hRenderGraphBuilder: RpsRenderGraphBuilder, size: usize, alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Declare an on-demand node type during the render graph construction.\n\n Normally, node declarations are specified in the RenderGraphSignature ahead of time. This function allows\n additional node declarations to be added. Note: The lifetime of the dynamic node declaration is temporary\n and it is only valid until the next render graph update.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param pNodeDesc                Pointer to a node description. Passing NULL for the name of the description\n                                 registers the node as a fallback for calling unknown nodes.\n\n @returns                        ID of the node declaration if successful, RPS_NODEDECL_ID_INVALID otherwise."]
    pub fn rpsRenderGraphDeclareDynamicNode(hRenderGraphBuilder: RpsRenderGraphBuilder, pNodeDesc: *const RpsNodeDesc) -> RpsNodeDeclId;
}
extern "C" {
    #[doc = " @brief Gets a variable from the render graph builder by its ID.\n\n @param hRenderGraphBuilder      Handle to the render graph builder to get the variable from.\n @param paramId                  Index of the parameter.\n\n @returns                        Variable identified by its ID."]
    pub fn rpsRenderGraphGetParamVariable(hRenderGraphBuilder: RpsRenderGraphBuilder, paramId: RpsParamId) -> RpsVariable;
}
extern "C" {
    #[doc = " @brief Gets the resource ID of a resource parameter by the parameter ID.\n\n Resource parameters have RPS_PARAMETER_FLAG_RESOURCE_BIT set and Resources are expected to be provided externally\n to the render graph.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param paramId                  Index of the parameter.\n\n @returns                        ID of the resource identified by its parameter ID."]
    pub fn rpsRenderGraphGetParamResourceId(hRenderGraphBuilder: RpsRenderGraphBuilder, paramId: RpsParamId) -> RpsResourceId;
}
extern "C" {
    #[doc = " @brief Declare a render graph managed resource.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param name                     Null terminated string with the name of the resource.\n @param localId                  Subprogram local ID of the resource.\n @param arg                      Variable for the ID of the resource\n\n @returns                        ID of the declared resource."]
    pub fn rpsRenderGraphDeclareResource(hRenderGraphBuilder: RpsRenderGraphBuilder, name: *const ::std::os::raw::c_char, localId: RpsResourceId, arg: RpsVariable) -> RpsResourceId;
}
extern "C" {
    #[doc = " @brief Adds a render graph node to a render graph.\n\n @param hRenderGraphBuilder              Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param nodeDeclId                       Node declaration ID.\n @param userTag                          User controlled tag for associations with a node call. Is accessible through\n                                         <c><i>RpsCmdCallbackContext</i></c>.\n @param callback                         Pointer to the callback function.\n @param pCallbackUserContext             Pointer to a user controlled structure to be passed to the callback.\n @param pArgs                            Pointer to the parameters used for the callback.\n                                         Must not be NULL if numArgs != 0.\n @param numArgs                          Number of parameters used for the callback.\n\n @returns                                ID of the command node."]
    pub fn rpsRenderGraphAddNode(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        nodeDeclId: RpsNodeDeclId,
        userTag: u32,
        callback: PFN_rpsCmdCallback,
        pCallbackUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsVariable,
        numArgs: u32
    ) -> RpsNodeId;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource info from a resource ID.\n\n Can be used to retrieve information such as the API resource handle, resource description and subresource info.\n\n @param hRenderGraph                         Handle to the render graph to get the resource info from. Must not be\n                                             RPS_NULL_HANDLE.\n @param resourceId                           The index to the resource to get. This can be the index returned by\n                                             rpsRenderGraphDeclareResource or rpsRenderGraphGetParamResourceId.\n @param temporalLayerIndex                   The temporal layer index. Ignored for non-temporal resource.\n @param pResourceInfo                        Pointer in which the runtime resource info is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetResourceInfo(hRenderGraph: RpsRenderGraph, resourceId: RpsResourceId, temporalLayerIndex: u32, pResourceInfo: *mut RpsRuntimeResourceInfo) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource info of an output parameter.\n\n @param hRenderGraph                         Handle to the render graph to get the resource info from.\n @param paramId                              Index of the resource parameter. Must be an output resource parameter\n                                             of a render graph entry (Declared as 'out [...] texture / buffer' in\n                                             RPSL or with\n                                             (RPS_PARAMETER_FLAG_OUT_BIT | RPS_PARAMETER_FLAG_RESOURCE_BIT) set.\n @param arrayOffset                          Offset of the first parameters for array parameters. Must be 0\n                                             otherwise.\n @param numResources                         Number of resources to get infos for.\n @param pResourceInfos                       Pointer to an array of <c><i>RpsRuntimeResourceInfo</i></c> in which the\n                                             numResources resource infos are returned. Must not be NULL if\n                                             numResources != 0.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetOutputParameterResourceInfos(
        hRenderGraph: RpsRenderGraph,
        paramId: RpsParamId,
        arrayOffset: u32,
        numResources: u32,
        pResourceInfos: *mut RpsRuntimeResourceInfo
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the main entry of a render graph.\n\n @param hRenderGraph             Handle to the render graph. Must not be RPS_NULL_HANDLE.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetMainEntry(hRenderGraph: RpsRenderGraph) -> RpsSubprogram;
}
#[doc = " @brief Parameters of a batch of commands to be recorded by the graphics API in use.\n\n These commands are the result of scheduling and have to be executed on the same queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCommandBatch {
    #[doc = "< Index of the queue to submit the current batch to."]
    pub queueIndex: u32,
    #[doc = "< Offset of the range of fence IDs into the"]
    pub waitFencesBegin: u32,
    #[doc = "< Number of fence IDs to wait for before submitting."]
    pub numWaitFences: u32,
    #[doc = "< Index of the fence to signal after submitting."]
    pub signalFenceIndex: u32,
    #[doc = "< Index of the first runtime command in the batch."]
    pub cmdBegin: u32,
    #[doc = "< Number of runtime commands in the batch."]
    pub numCmds: u32
}
#[doc = " @brief Parameters of the command batch layout of a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphBatchLayout {
    #[doc = "< Number of command batches."]
    pub numCmdBatches: u32,
    #[doc = "< Number of fence signals in the pipeline."]
    pub numFenceSignals: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsCommandBatch</i></c> with"]
    pub pCmdBatches: *const RpsCommandBatch,
    #[doc = "< Pointer to an array of <c><i>const uint32_t</i></c> numFenceSignals"]
    pub pWaitFenceIndices: *const u32
}
#[doc = "< No recording options."]
pub const RpsRecordCommandFlagBits_RPS_RECORD_COMMAND_FLAG_NONE: RpsRecordCommandFlagBits = 0;
#[doc = "< Enables per-command debug markers during"]
pub const RpsRecordCommandFlagBits_RPS_RECORD_COMMAND_FLAG_ENABLE_COMMAND_DEBUG_MARKERS: RpsRecordCommandFlagBits = 1;
#[doc = " @brief Bitflags for recording commands."]
pub type RpsRecordCommandFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRecordCommandFlagBits</i></c>."]
pub type RpsRecordCommandFlags = RpsFlags32;
#[doc = " @brief Parameters for recording commands using a processed render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphRecordCommandInfo {
    #[doc = "< Handle to the runtime command buffer object."]
    pub hCmdBuffer: RpsRuntimeCommandBuffer,
    #[doc = "< User defined context to be passed to the callbacks during recording."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Index of the frame to record commands for."]
    pub frameIndex: u64,
    #[doc = "< Index of the first command to be recorded."]
    pub cmdBeginIndex: u32,
    #[doc = "< Number of commands to record."]
    pub numCmds: u32,
    #[doc = "< Flags for specifying recording behavior."]
    pub flags: RpsRecordCommandFlags
}
extern "C" {
    #[doc = " @brief Gets the command batch layout of a render graph.\n\n @param hRenderGraph                         Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pBatchLayout                         Pointer to return the batch layout in. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetBatchLayout(hRenderGraph: RpsRenderGraph, pBatchLayout: *mut RpsRenderGraphBatchLayout) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Records graphics API commands from a processed render graph.\n\n @param hRenderGraph                         Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pRecordInfo                          Pointer to recording parameters. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphRecordCommands(hRenderGraph: RpsRenderGraph, pRecordInfo: *const RpsRenderGraphRecordCommandInfo) -> RpsResult;
}
#[doc = " @brief Diagnostic information for a command of the render graph command stream."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsCmdDiagnosticInfo {
    #[doc = "< Index of the command in the scheduled command stream. Also used for"]
    pub cmdIndex: u32,
    #[doc = "< Indicator for transition commands."]
    pub isTransition: RpsBool,
    pub __bindgen_anon_1: RpsCmdDiagnosticInfo__bindgen_ty_1
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsCmdDiagnosticInfo__bindgen_ty_1 {
    pub cmd: RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1,
    pub transition: RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Dummy value to avoid an empty struct."]
    pub dummy: u32
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Access before the current transition."]
    pub prevAccess: RpsAccessAttr,
    #[doc = "< Access after the current transition."]
    pub nextAccess: RpsAccessAttr,
    #[doc = "< Access range for the transition."]
    pub range: RpsSubresourceRange,
    #[doc = "< Index of the resource to transition."]
    pub resourceIndex: u32
}
#[doc = " @brief Diagnostic information for a resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDiagnosticInfo {
    #[doc = "< Null terminated string with the name of the resource."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Index to the first temporal child of the temporal parent. Only for"]
    pub temporalChildIndex: u32,
    #[doc = "< Indicator for external resources."]
    pub isExternal: RpsBool,
    #[doc = "< Description of the resource."]
    pub desc: RpsResourceDesc,
    #[doc = "< Clear value of the resource."]
    pub clearValue: RpsClearValue,
    #[doc = "< Combination of all accesses of the resource throughout the frame."]
    pub allAccesses: RpsAccessAttr,
    #[doc = "< Initial access of the resource."]
    pub initialAccess: RpsAccessAttr,
    #[doc = "< Index of the first command to access the resource."]
    pub lifetimeBegin: u32,
    #[doc = "< Index of the last command to access the resource."]
    pub lifetimeEnd: u32,
    #[doc = "< Allocation requirements for the memory of the resource."]
    pub allocRequirement: RpsGpuMemoryRequirement,
    #[doc = "< Allocation placement for the memory of the resource."]
    pub allocPlacement: RpsHeapPlacement,
    #[doc = "< Handle to the backend specific resource."]
    pub hRuntimeResource: RpsRuntimeResource
}
#[doc = " @brief Diagnostic information for a heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsHeapDiagnosticInfo {
    #[doc = "< Total size of the heap. May be 0 if the heap is not created in the backend"]
    pub size: u64,
    #[doc = "< Amount of memory allocated from the heap."]
    pub usedSize: u64,
    #[doc = "< Maximum amount of memory ever allocated from the heap."]
    pub maxUsedSize: u64,
    #[doc = "< Alignment of the heap in bytes."]
    pub alignment: u32,
    #[doc = "< Index of the backend specific memory type of the heap."]
    pub memoryTypeIndex: u32,
    #[doc = "< Handle to the backend specific heap implementation."]
    pub hRuntimeHeap: RpsRuntimeHeap
}
#[doc = " @brief Diagnostic information for parts of a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphDiagnosticInfo {
    #[doc = "< Number of resource infos."]
    pub numResourceInfos: u32,
    #[doc = "< Number of command infos."]
    pub numCommandInfos: u32,
    #[doc = "< Number of heap infos."]
    pub numHeapInfos: u32,
    #[doc = " Pointer to an array of <c><i>RpsResourceDiagnosticInfo</i></c> with numResourceInfos resource infos."]
    pub pResourceDiagInfos: *const RpsResourceDiagnosticInfo,
    #[doc = " Pointer to an array of <c><i>RpsCmdDiagnosticInfo</i></c> with numCommandInfos command infos."]
    pub pCmdDiagInfos: *const RpsCmdDiagnosticInfo,
    #[doc = " Pointer to an array of <c><i>RpsHeapDiagnosticInfo</i></c> with numHeapInfosheap infos."]
    pub pHeapDiagInfos: *const RpsHeapDiagnosticInfo
}
#[doc = "< Diagnostic info is taken from the latest frame."]
pub const RpsRenderGraphDiagnosticInfoFlagBits_RPS_RENDER_GRAPH_DIAGNOSTIC_INFO_DEFAULT: RpsRenderGraphDiagnosticInfoFlagBits = 0;
#[doc = "< The previously cached diagnostic info is returned\n< if not called for the first time."]
pub const RpsRenderGraphDiagnosticInfoFlagBits_RPS_RENDER_GRAPH_DIAGNOSTIC_INFO_USE_CACHED_BIT: RpsRenderGraphDiagnosticInfoFlagBits = 1;
#[doc = " @brief Bitflags for diagnostic info modes."]
pub type RpsRenderGraphDiagnosticInfoFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRenderGraphDiagnosticInfoFlagBits</i></c>."]
pub type RpsRenderGraphDiagnosticInfoFlags = RpsFlags32;
extern "C" {
    #[doc = " @brief Gets diagnostic information from a render graph.\n\n Diagnostic information is intended to be consumed by tools related to RPS, e.g. the visualizer tool set.\n\n @param hRenderGraph                      Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pDiagInfo                         Pointer in which the diagnostic information is returned. Must not be NULL.\n @param diagnosticFlags                   Flags for the diagnostic mode.\n\n @returns                                 Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetDiagnosticInfo(hRenderGraph: RpsRenderGraph, pDiagInfo: *mut RpsRenderGraphDiagnosticInfo, diagnosticFlags: RpsRenderGraphDiagnosticInfoFlags) -> RpsResult;
}
#[doc = " @brief Parameters of a command callback context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdCallbackContext {
    #[doc = " Handle to the command buffer for command recording."]
    pub hCommandBuffer: RpsRuntimeCommandBuffer,
    #[doc = " User context passed as RpsRenderGraphRecordCommandInfo::pUserContext. Can vary per rpsRenderGraphRecordCommands\n call and can e.g. be used as per-thread context if doing multi-threaded recording."]
    pub pUserRecordContext: *mut ::std::os::raw::c_void,
    #[doc = " User context specified with the command node callback function, for example via a rpsProgramBindNode call. Can\n vary per callback."]
    pub pCmdCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to an array of <c><i>void* const</i></c> with numArgs pointers to arguments to use for the callback.\n Must not be NULL if numArgs != 0."]
    pub ppArgs: *const *mut ::std::os::raw::c_void,
    #[doc = " Number of arguments defined for the callback."]
    pub numArgs: u32,
    #[doc = " User defined tag for associations with a specific node. Can be set by passing a value to\n <c><i>rpsCmdCallNode</i></c>."]
    pub userTag: u32
}
#[doc = " @brief Parameters for accessing a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceAccessInfo {
    #[doc = "< ID of the resource to access."]
    pub resourceId: RpsResourceId,
    #[doc = "< Subresource range to access."]
    pub range: RpsSubresourceRange,
    #[doc = "< Attributes for access type and shader stages."]
    pub access: RpsAccessAttr,
    #[doc = "< Format to use for accessing."]
    pub viewFormat: RpsFormat
}
extern "C" {
    #[doc = " @brief Gets the render targets parameters from the current recording context.\n\n Must only be called from a graphics node callback.\n\n @param pContext                             Pointer to the current recording context. Must not be NULL.\n @param pRenderTargetInfo                    Pointer in which the render target parameters are returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetRenderTargetsInfo(pContext: *const RpsCmdCallbackContext, pRenderTargetInfo: *mut RpsCmdRenderTargetInfo) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the viewport info from the current recording context.\n\n Must only be called from a graphics node callback.\n\n @param pContext                             Pointer to the current recording context. Must not be NULL\n @param pViewportInfo                        Pointer in which the viewport parameters are returned to.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetViewportInfo(pContext: *const RpsCmdCallbackContext, pViewportInfo: *mut RpsCmdViewportInfo) -> RpsResult;
}
#[doc = " @brief Parameters for explicitly beginning a render pass from a command callback.\n\n Intended for controlling RenderPass suspend / resume & secondary command buffer behaviors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdRenderPassBeginInfo {
    #[doc = "< Flags for render pass properties."]
    pub flags: RpsRuntimeRenderPassFlags
}
extern "C" {
    #[doc = " @brief Clones a command callback context to create a secondary context and assigns it a new command buffer.\n\n The cloned context inherits states from the context being cloned, such as current command info and command\n arguments. The typical use case is multi-threaded command recording from within a node callback.\n Must be synchronized by the caller if called from multiple threads. The created context pointer is valid until the\n next render graph update.\n\n @param pContext                             Pointer to the current command callback context.\n @param hCmdBufferForDerivedContext          Handle to the command buffer to be associated with the new context.\n @param ppDerivedContext                     Pointer in which a pointer to the cloned command callback context is\n                                             returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdCloneContext(
        pContext: *const RpsCmdCallbackContext,
        hCmdBufferForDerivedContext: RpsRuntimeCommandBuffer,
        ppDerivedContext: *mut *const RpsCmdCallbackContext
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Begins a rasterization rendering pass.\n\n This may begin e.g. a VkRenderPass or set up render targets and viewport/scissor rect states for APIs that do not\n support a render pass objects. Usually used for multi-threaded rendering from within a command callback.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param flags                                Flags for the render pass behavior.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdBeginRenderPass(pContext: *const RpsCmdCallbackContext, flags: RpsRuntimeRenderPassFlags) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Ends a rasterization rendering pass.\n\n Must be paird with rpsCmdBeginRenderPass. Usually used for multi-threaded rendering from within a command callback.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdEndRenderPass(pContext: *const RpsCmdCallbackContext) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Sets a new command buffer to be used for command recording.\n\n RPS does not keep of previously used command buffers. It is the responsibility of the application to track and\n submit them in order accordingly. Usually used for multi-threaded rendering.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param hCmdBuffer                           Handle to the new command buffer.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdSetCommandBuffer(pContext: *const RpsCmdCallbackContext, hCmdBuffer: RpsRuntimeCommandBuffer) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the description of the current cmd node.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param ppNodeName                           Pointer in which a null terminated string with the name of the node\n                                             is returned. Must not be NULL.\n @param pNodeNameLength                      Pointer in which the node name length is returned. Can be NULL.\n\n @return                                     Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetNodeName(pContext: *const RpsCmdCallbackContext, ppNodeName: *mut *const ::std::os::raw::c_char, pNodeNameLength: *mut usize) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the description of a node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param paramID                              Index of the parameter in the current command node callback.\n @param pDesc                                Pointer in which the parameter description is returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetParamDesc(pContext: *const RpsCmdCallbackContext, paramID: RpsParamId, pDesc: *mut RpsParameterDesc) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of resource descriptions of a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the resource descriptions from. Must be a resource\n                                     array argument if numDescs > 1.\n @param srcArrayOffset               Offset to the first resource description to get.\n @param pResourceDescs               Pointer to an array of <c><i>RpsResourceDesc</i></c> in which the numDescs\n                                     resource descriptions are returned. Must not be NULL if numDescs != 0.\n @param numDescs                     Number of resource descriptions to get. Requires srcArrayOffset + numDescs to\n                                     be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceDescArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pResourceDescs: *mut RpsResourceDesc,
        numDescs: u32
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the resource description from a node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pResourceDesc                        Pointer in which the resource description is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceDesc(pContext: *const RpsCmdCallbackContext, argIndex: RpsParamId, pResourceDesc: *mut RpsResourceDesc) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of runtime resources from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the runtime resource from. Must be a resource array\n                                     argument if numResources > 1.\n @param srcArrayOffset               Offset to the first runtime resource to get.\n @param pRuntimeResources            Pointer to an array of <c><i>RpsRuntimeResource</i></c> in which the\n                                     numResources resource descriptions are returned.\n                                     Must not be NULL if numResources != 0.\n @param numResources                 Number of runtime resources to get. Requires srcArrayOffset + numResources to\n                                     be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgRuntimeResourceArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pRuntimeResources: *mut RpsRuntimeResource,
        numResources: u32
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource from a resource node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pRuntimeResource                     Pointer in which the runtime resource is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgRuntimeResource(pContext: *const RpsCmdCallbackContext, argIndex: RpsParamId, pRuntimeResource: *mut RpsRuntimeResource) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of resource access infos from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the resource access infos from. Must be a resource\n                                     array argument if numAccessess > 1.\n @param srcArrayOffset               Offset to the first resource access info to get.\n @param pResourceAccessInfos         Pointer to an array of <c><i>RpsResourceAccessInfo</i></c> in which the\n                                     numAccessess resource access infos are returned.\n                                     Must not be NULL if numAccessess != 0.\n @param numAccessess                 Number of resource access infos to get. Requires srcArrayOffset +\n                                     to be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceAccessInfoArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pResourceAccessInfos: *mut RpsResourceAccessInfo,
        numAccessess: u32
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the resource access info from a resource node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pResourceAccessInfo                  Pointer in which the resource access info is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceAccessInfo(pContext: *const RpsCmdCallbackContext, argIndex: RpsParamId, pResourceAccessInfo: *mut RpsResourceAccessInfo) -> RpsResult;
}
#[doc = " @brief Signature of functions for acquiring command buffers in a simplified execution mode.\n\n Reserved for future use."]
pub type PFN_rpsAcquireRuntimeCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        queueIndex: u32,
        numCmdBuffers: u32,
        pCmdBuffers: *mut RpsRuntimeCommandBuffer,
        pCmdBufferIdentifiers: *mut u32
    ) -> RpsResult
>;
#[doc = " @brief Signature of functions for submitting command buffers in a simplified execution mode.\n\n Reserved for future use."]
pub type PFN_rpsSubmitRuntimeCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        queueIndex: u32,
        pRuntimeCmdBufs: *const RpsRuntimeCommandBuffer,
        numRuntimeCmdBufs: u32,
        waitId: u32,
        signalId: u32
    ) -> RpsResult
>;
#[doc = " @brief Parameters for executing a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphExecuteInfo {
    #[doc = "< Pointer to a user defined context to be passed"]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to a function to acquire command"]
    pub pfnAcquireRuntimeCmdBufCb: PFN_rpsAcquireRuntimeCommandBuffer,
    #[doc = "< Pointer to a function to submit command"]
    pub pfnSubmitRuntimeCmdBufCb: PFN_rpsSubmitRuntimeCommandBuffer
}
extern "C" {
    #[doc = " @brief Executes a render graph.\n\n @param hRenderGraph                                 Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pExecuteInfo                                 Pointer to render graph execution parameters. Must not be NULL.\n\n @returns                                            Result code of the operation. See <c><i>RpsResult</i></c> for\n                                                     more info."]
    pub fn rpsRenderGraphExecute(hRenderGraph: RpsRenderGraph, pExecuteInfo: *const RpsRenderGraphExecuteInfo) -> RpsResult;
}
#[doc = "< No special behavior."]
pub const RpsVKRuntimeFlagBits_RPS_VK_RUNTIME_FLAG_NONE: RpsVKRuntimeFlagBits = 0;
#[doc = "< Prefers using render passes."]
pub const RpsVKRuntimeFlagBits_RPS_VK_RUNTIME_FLAG_PREFER_RENDER_PASS: RpsVKRuntimeFlagBits = 2;
#[doc = "< Disables viewport flipping. By default RPS flips the viewport"]
pub const RpsVKRuntimeFlagBits_RPS_VK_RUNTIME_FLAG_DONT_FLIP_VIEWPORT: RpsVKRuntimeFlagBits = 4;
#[doc = " @brief Bitflags for VK runtime behavior."]
pub type RpsVKRuntimeFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsVKRuntimeFlagBits</i></c>"]
pub type RpsVKRuntimeFlags = u32;
#[doc = " @brief Creation parameters for an RPS device with a Vulkan backend."]
#[repr(C)]
pub struct RpsVKRuntimeDeviceCreateInfo {
    #[doc = "< Pointer to general RPS device creation parameters."]
    pub pDeviceCreateInfo: *const RpsDeviceCreateInfo,
    #[doc = "< Pointer to general RPS runtime creation info. Passing"]
    pub pRuntimeCreateInfo: *const RpsRuntimeDeviceCreateInfo,
    #[doc = "< Handle to the VK device to use for the runtime. Must not"]
    pub hVkDevice: Device,
    #[doc = "< Handle to the VK physical device to use for the runtime."]
    pub hVkPhysicalDevice: PhysicalDevice,
    #[doc = "< VK runtime flags."]
    pub flags: RpsVKRuntimeFlags
}
extern "C" {
    #[doc = " @brief Creates a VK runtime device.\n\n @param pCreateInfo                  Pointer to creation parameters. Must not be NULL.\n @param phDevice                     Pointer to a handle in which the device is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info.\n @ingroup RpsVKRuntimeDevice"]
    pub fn rpsVKRuntimeDeviceCreate(pCreateInfo: *const RpsVKRuntimeDeviceCreateInfo, phDevice: *mut RpsDevice) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of VK image view handles from an image resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view handles from. Must be an image\n                                     resource array argument if numImageViews > 1.\n @param srcArrayOffset               Offset to the first image view handle to get.\n @param pImageViews                  Pointer to an array of <c><i>VkImageView</i></c> in which the numImageViews\n                                     image view handles are returned. Must not be NULL if numImageViews != 0.\n @param numImageViews                Number of image view handles to get. Requires srcArrayOffset + numImageViews to\n                                     be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImageViewArray(pContext: *const RpsCmdCallbackContext, argIndex: u32, srcArrayOffset: u32, pImageViews: *mut ImageView, numImageViews: u32) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK image view handle from an image resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view from. Must be an image resource\n                                     argument.\n @param pImageView                   Pointer in which the image view handle is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImageView(pContext: *const RpsCmdCallbackContext, argIndex: u32, pImageView: *mut ImageView) -> RpsResult;
}
#[doc = " @brief Parameters of a VK image view info."]
#[repr(C)]
pub struct RpsVkImageViewInfo {
    #[doc = "< Handle to the image view."]
    pub hImageView: ImageView,
    #[doc = "< Layout of the viwed image."]
    pub layout: ImageLayout
}
extern "C" {
    #[doc = " @brief Gets an array of VK image view infos from an image resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view infos from. Must be an image\n                                     resource array argument if numImageViewInfos > 1.\n @param srcArrayOffset               Offset to the first image view info to get.\n @param pImageViewInfos              Pointer to an array of <c><i>RpsVkImageViewInfo</i></c> in which the\n                                     numImageViewInfos image view infos are returned. Must not be NULL if\n                                     numImageViewInfos != 0.\n @param numImageViewInfos            Number of image view infos to get. Requires srcArrayOffset + numImageViewInfos\n                                     to be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImageViewInfoArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: u32,
        srcArrayOffset: u32,
        pImageViewInfos: *mut RpsVkImageViewInfo,
        numImageViewInfos: u32
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK image view info from an image view node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view info from. Must be an image resource\n                                     argument.\n @param pImageViewInfo               Pointer in which the image view info is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImageViewInfo(pContext: *const RpsCmdCallbackContext, argIndex: u32, pImageViewInfo: *mut RpsVkImageViewInfo) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of VK image handles from an image resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view infos from. Must be an image\n                                     resource array argument if numImages > 1.\n @param srcArrayOffset               Offset to the first image handle to get.\n @param pImages                      Pointer to an array of <c><i>VkImage</i></c> in which the numImages image\n                                     handles are returned. Must not be NULL if numImages != 0.\n @param numImages                    Number of image handles to get. Requires srcArrayOffset + numImages to be\n                                     less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImageArray(pContext: *const RpsCmdCallbackContext, argIndex: u32, srcArrayOffset: u32, pImages: *mut Image, numImages: u32) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK image handle from an image resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image handle info from. Must be an image\n                                     resource argument.\n @param pImage                       Pointer in which the image handle is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgImage(pContext: *const RpsCmdCallbackContext, argIndex: u32, pImage: *mut Image) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of VK buffer view handles from a buffer resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the buffer view handle from. Must be a buffer\n                                     resource array argument if numBufferViews > 1.\n @param srcArrayOffset               Offset to the first buffer view handle to get.\n @param pBufferViews                 Pointer to an array of <c><i>VkBufferView</i></c> in which the numBufferViews\n                                     buffer view handles are returned. Must not be NULL if numBufferViews != 0.\n @param numBufferViews               Number of buffer view handles to get. Requires srcArrayOffset + numBufferViews\n                                     to be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgBufferViewArray(pContext: *const RpsCmdCallbackContext, argIndex: u32, srcArrayOffset: u32, pBufferViews: *mut BufferView, numBufferViews: u32) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK buffer view handle from an buffer resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the buffer view handle from. Must be a buffer\n                                     resource argument.\n @param pBufferViews                 Pointer in which the buffer view handle is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgBufferView(pContext: *const RpsCmdCallbackContext, argIndex: u32, pBufferViews: *mut BufferView) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of VK buffer handles from a buffer resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the image view infos from. Must be a buffer\n                                     resource array argument if numBuffers > 1.\n @param srcArrayOffset               Offset to the first buffer handle to get.\n @param pBuffers                     Pointer to an array of <c><i>VkBuffer</i></c> in which the numBuffers buffer\n                                     handles are returned. Must not be NULL if numBuffers != 0.\n @param numBuffers                   Number of buffer handles to get. Requires srcArrayOffset + numBuffers to be\n                                     less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgBufferArray(pContext: *const RpsCmdCallbackContext, argIndex: u32, srcArrayOffset: u32, pBuffers: *mut Buffer, numBuffers: u32) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK buffer handle from a buffer resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the buffer handle from. Must be a buffer resource\n                                     argument.\n @param pBuffer                      Pointer in which the buffer handle is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgBuffer(pContext: *const RpsCmdCallbackContext, argIndex: u32, pBuffer: *mut Buffer) -> RpsResult;
}
#[doc = " @brief Parameters of a VK memory range."]
#[repr(C)]
pub struct RpsVkDeviceMemoryRange {
    #[doc = "< Handle to the device memory."]
    pub hMemory: DeviceMemory,
    #[doc = "< Offset into the device memory in bytes."]
    pub offset: usize,
    #[doc = "< Size of the range in bytes."]
    pub size: usize
}
extern "C" {
    #[doc = " @brief Gets an array of VK memory ranges from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the memory ranges from. Must be a resource array\n                                     argument if numRanges > 1.\n @param srcArrayOffset               Offset to the first memory range to get. Pointer to an array of\n                                     <c><i>RpsVkDeviceMemoryRange</i></c> in which the numRanges memory ranges are\n                                     returned. Must not be NULL if numRanges != 0.\n @param pMemoryRanges                Pointer to an array of <c><i>RpsVkDeviceMemoryRange</i></c> in which the\n                                     numRanges memory ranges are returned. Must not be NULL if numRanges != 0.\n @param numRanges                    Number of memory ranges to get. Requires srcArrayOffset + numRanges to be\n                                     less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgGpuMemoryArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: u32,
        srcArrayOffset: u32,
        pMemoryRanges: *mut RpsVkDeviceMemoryRange,
        numRanges: u32
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets a VK memory range from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the memory range from. Must be a resource argument.\n @param pMemoryRange                 Pointer in which the memory range is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdArgGpuMemory(pContext: *const RpsCmdCallbackContext, argIndex: u32, pMemoryRange: *mut RpsVkDeviceMemoryRange) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the render pass handle of the current node.\n\n @param pContext                     Callback context of the current command.\n @param pRenderPass                  Pointer in which the render pass handle is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsVKGetCmdRenderPass(pContext: *const RpsCmdCallbackContext, pRenderPass: *mut RenderPass) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Converts an RPS format to a VK format.\n\n @param rpsFormat                RPS format to convert.\n\n @returns                        Converted VK format."]
    pub fn rpsFormatToVK(rpsFormat: RpsFormat) -> Format;
}
extern "C" {
    #[doc = " @brief Converts a VK format to an RPS format.\n\n @param vkFormat                 VK format to convert.\n\n @returns                        Converted RPS format."]
    pub fn rpsFormatFromVK(vkFormat: Format) -> RpsFormat;
}
